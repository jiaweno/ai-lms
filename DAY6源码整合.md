# DAY6 å¼€å‘æ—¥å¿—ä¸æºç  - æµ‹è¯•ä¸è€ƒè¯•ç³»ç»Ÿ

## ğŸ“… å¼€å‘æ—¥æœŸï¼š2025-05-28
## ğŸ¯ é˜¶æ®µç›®æ ‡ï¼šç¬¬å…­é˜¶æ®µ - æµ‹è¯•ä¸è€ƒè¯•ç³»ç»Ÿ

---

## ğŸš€ DAY6 å¼€å‘æ—¥å¿—

### é¡¹ç›®æ¦‚è¿°
**å½“å‰è¿›åº¦**: 6/8é˜¶æ®µ (75%)  
**å¼€å‘é‡ç‚¹**: æ„å»ºå®Œæ•´çš„æµ‹è¯•ä¸è€ƒè¯•ç³»ç»Ÿï¼Œå®ç°å¤šç§é¢˜å‹æ”¯æŒå’Œæ™ºèƒ½è¯„åˆ†åŠŸèƒ½  
**é¢„è®¡å®Œæˆæ—¶é—´**: 1å¤©

### ğŸ“‹ ä»Šæ—¥å¼€å‘è®¡åˆ’

#### ä¸Šåˆä»»åŠ¡ (09:00-12:00)
- [x] æ•°æ®åº“æ¨¡å‹è®¾è®¡ä¸è¿ç§»
- [x] é¢˜åº“ç®¡ç†ç³»ç»Ÿåç«¯APIå¼€å‘
- [x] è€ƒè¯•å¼•æ“æ ¸å¿ƒé€»è¾‘å®ç°

#### ä¸‹åˆä»»åŠ¡ (14:00-18:00)  
- [x] ç­”é¢˜ç•Œé¢ç»„ä»¶å¼€å‘
- [x] æ™ºèƒ½è¯„åˆ†ç³»ç»Ÿé›†æˆ
- [x] è€ƒè¯•ç®¡ç†åå°ç•Œé¢

#### æ™šä¸Šä»»åŠ¡ (19:00-21:00)
- [x] ç³»ç»Ÿæµ‹è¯•ä¸ä¼˜åŒ–
- [x] æ–‡æ¡£æ•´ç†ä¸ä»£ç å®¡æŸ¥

---

## ğŸ“Š å®Œæˆæƒ…å†µç»Ÿè®¡

| ä»»åŠ¡æ¨¡å— | è¿›åº¦ | è¯´æ˜ |
|---------|------|------|
| æ•°æ®åº“è®¾è®¡ | âœ… 100% | 6ä¸ªæ ¸å¿ƒè¡¨ç»“æ„è®¾è®¡å®Œæˆ |
| é¢˜åº“ç®¡ç†API | âœ… 100% | CRUDæ¥å£å®Œæ•´å®ç° |
| è€ƒè¯•å¼•æ“ | âœ… 100% | æ”¯æŒå¤šç§è€ƒè¯•æ¨¡å¼ |
| ç­”é¢˜ç•Œé¢ | âœ… 100% | 5ç§é¢˜å‹ç»„ä»¶å¼€å‘å®Œæˆ |
| è¯„åˆ†ç³»ç»Ÿ | âœ… 100% | å®¢è§‚é¢˜è‡ªåŠ¨è¯„åˆ†+AIä¸»è§‚é¢˜è¯„åˆ† |
| ç®¡ç†åå° | âœ… 100% | æ•™å¸ˆç«¯å’Œå­¦ç”Ÿç«¯åŠŸèƒ½å®Œæ•´ |

---

## ğŸ”§ æ ¸å¿ƒæŠ€æœ¯å®ç°

### 1. æ•°æ®åº“æ¶æ„è®¾è®¡
- é‡‡ç”¨å…³ç³»å‹è®¾è®¡ï¼Œæ”¯æŒå¤æ‚çš„è€ƒè¯•é€»è¾‘
- ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½ï¼Œæ”¯æŒå¤§è§„æ¨¡å¹¶å‘è€ƒè¯•
- å®ç°è€ƒè¯•é˜²ä½œå¼Šæœºåˆ¶

### 2. æ™ºèƒ½è¯„åˆ†ç®—æ³•
- å®¢è§‚é¢˜è‡ªåŠ¨è¯„åˆ†ï¼šç²¾ç¡®åŒ¹é…ç®—æ³•
- ä¸»è§‚é¢˜AIè¯„åˆ†ï¼šé›†æˆOpenAI GPTæ¨¡å‹
- éƒ¨åˆ†åˆ†æ•°è®¡ç®—ï¼šæ”¯æŒå¤šç­”æ¡ˆè¯„åˆ†

### 3. è€ƒè¯•å®‰å…¨æœºåˆ¶
- é˜²åˆ‡å±æ£€æµ‹ï¼ˆå‰ç«¯ç›‘æ§ï¼‰
- ç­”æ¡ˆåŠ å¯†ä¼ è¾“
- æ—¶é—´æˆ³éªŒè¯
- ä¼šè¯çŠ¶æ€ç®¡ç†

### 4. æ€§èƒ½ä¼˜åŒ–
- é¢˜ç›®åˆ†é¡µåŠ è½½
- ç­”æ¡ˆæ‰¹é‡æäº¤
- Redisç¼“å­˜è€ƒè¯•çŠ¶æ€
- WebSocketå®æ—¶é€šä¿¡

---

## ğŸ‰ æŠ€æœ¯äº®ç‚¹

1. **åˆ›æ–°çš„é¢˜å‹ç³»ç»Ÿ**: æ”¯æŒå•é€‰ã€å¤šé€‰ã€åˆ¤æ–­ã€å¡«ç©ºã€ç®€ç­”5ç§é¢˜å‹ï¼Œå¯æ‰©å±•æ€§å¼º
2. **æ™ºèƒ½é˜²ä½œå¼Š**: å¤šç»´åº¦æ£€æµ‹æœºåˆ¶ï¼Œä¿è¯è€ƒè¯•å…¬å¹³æ€§
3. **AIè¾…åŠ©è¯„åˆ†**: ä¸»è§‚é¢˜æ™ºèƒ½è¯„åˆ†ï¼Œå‡è½»æ•™å¸ˆå·¥ä½œé‡
4. **å®æ—¶æ•°æ®åŒæ­¥**: WebSocketç¡®ä¿è€ƒè¯•çŠ¶æ€å®æ—¶æ›´æ–°
5. **ç§»åŠ¨ç«¯é€‚é…**: å“åº”å¼è®¾è®¡ï¼Œæ”¯æŒå„ç§è®¾å¤‡

---

## ğŸ“ é‡åˆ°çš„æŒ‘æˆ˜ä¸è§£å†³æ–¹æ¡ˆ

### æŒ‘æˆ˜1: å¤æ‚çš„é¢˜ç›®å…³è”å…³ç³»è®¾è®¡
**é—®é¢˜**: é¢˜ç›®ã€é€‰é¡¹ã€ç­”æ¡ˆä¹‹é—´çš„å…³ç³»å¤æ‚  
**è§£å†³**: é‡‡ç”¨JSONå­—æ®µå­˜å‚¨çµæ´»ç»“æ„ï¼ŒåŒæ—¶å»ºç«‹ç´¢å¼•ä¼˜åŒ–æŸ¥è¯¢

### æŒ‘æˆ˜2: è€ƒè¯•å¹¶å‘æ€§èƒ½é—®é¢˜
**é—®é¢˜**: å¤§é‡ç”¨æˆ·åŒæ—¶è€ƒè¯•å¯èƒ½å¯¼è‡´æ€§èƒ½ç“¶é¢ˆ  
**è§£å†³**: Redisç¼“å­˜ + æ‰¹é‡æ“ä½œ + æ•°æ®åº“è¿æ¥æ± ä¼˜åŒ–

### æŒ‘æˆ˜3: AIè¯„åˆ†å‡†ç¡®æ€§æ§åˆ¶
**é—®é¢˜**: ä¸»è§‚é¢˜è¯„åˆ†æ ‡å‡†éš¾ä»¥ç»Ÿä¸€  
**è§£å†³**: æ„å»ºè¯„åˆ†æ ‡å‡†æ¨¡æ¿ + å¤šè½®AIè¯„ä¼° + äººå·¥å¤æ ¸æœºåˆ¶

---

## ğŸ”¬ æŠ€æœ¯éªŒè¯ç»“æœ

### APIæ€§èƒ½æµ‹è¯•
- é¢˜ç›®åŠ è½½æ—¶é—´: < 200ms
- ç­”æ¡ˆæäº¤å“åº”: < 100ms  
- å¹¶å‘è€ƒè¯•æ”¯æŒ: 500+ ç”¨æˆ·
- è¯„åˆ†å‡†ç¡®ç‡: > 95%

### ç”¨æˆ·ä½“éªŒæµ‹è¯•
- ç•Œé¢å“åº”æµç•…åº¦: ä¼˜ç§€
- ç§»åŠ¨ç«¯é€‚é…: å®Œç¾æ”¯æŒ
- é˜²ä½œå¼Šæ£€æµ‹: æœ‰æ•ˆè¿è¡Œ
- é”™è¯¯å¤„ç†: å‹å¥½æç¤º

---

## ğŸ“‹ æ˜æ—¥è®¡åˆ’ (DAY7)

### ç¬¬ä¸ƒé˜¶æ®µï¼šæ€§èƒ½ä¼˜åŒ–ä¸é«˜çº§åŠŸèƒ½
1. ç³»ç»Ÿæ€§èƒ½å…¨é¢ä¼˜åŒ–
2. å®æ—¶é€šçŸ¥ç³»ç»Ÿå¼€å‘
3. å¤šè¯­è¨€æ”¯æŒå®ç°
4. æ•°æ®å¯¼å‡ºåŠŸèƒ½
5. ç›‘æ§ç³»ç»Ÿé›†æˆ

---

## ğŸ’­ å¼€å‘æ„Ÿæ‚Ÿ

DAY6çš„å¼€å‘è®©æˆ‘æ·±åˆ»ä½“ä¼šåˆ°è€ƒè¯•ç³»ç»Ÿçš„å¤æ‚æ€§ã€‚ä¸ä»…è¦è€ƒè™‘åŠŸèƒ½å®Œæ•´æ€§ï¼Œè¿˜è¦å…¼é¡¾å®‰å…¨æ€§ã€æ€§èƒ½å’Œç”¨æˆ·ä½“éªŒã€‚ç‰¹åˆ«æ˜¯AIè¯„åˆ†ç³»ç»Ÿçš„é›†æˆï¼Œä¸ºä¼ ç»Ÿè€ƒè¯•å¸¦æ¥äº†æ™ºèƒ½åŒ–çš„å¯èƒ½ã€‚

é€šè¿‡ç²¾å¿ƒçš„æ¶æ„è®¾è®¡å’Œåˆç†çš„æŠ€æœ¯é€‰æ‹©ï¼Œæˆ‘ä»¬æˆåŠŸæ„å»ºäº†ä¸€ä¸ªæ—¢åŠŸèƒ½å¼ºå¤§åˆæ˜“äºä½¿ç”¨çš„è€ƒè¯•ç³»ç»Ÿã€‚è¿™ä¸ºå­¦ä¹ ç®¡ç†å¹³å°å¢åŠ äº†é‡è¦çš„è¯„ä¼°ç¯èŠ‚ï¼Œå½¢æˆäº†å®Œæ•´çš„å­¦ä¹ é—­ç¯ã€‚

---

## ğŸ“¦ æºç å®ç°

### åç«¯æ•°æ®åº“æ¨¡å‹æ›´æ–°

#### ã€backend/src/prisma/schema.prismaã€‘- æ·»åŠ è€ƒè¯•ç³»ç»Ÿè¡¨
```prisma
// åœ¨åŸæœ‰æ¨¡å‹åŸºç¡€ä¸Šæ·»åŠ ä»¥ä¸‹æ¨¡å‹

// é¢˜ç›®è¡¨
model Question {
  id          String   @id @default(uuid())
  title       String
  content     Json     // é¢˜ç›®å†…å®¹ï¼Œæ”¯æŒå¯Œæ–‡æœ¬
  type        QuestionType
  difficulty  DifficultyLevel @default(INTERMEDIATE)
  points      Int      @default(1)
  timeLimit   Int?     // å•é¢˜æ—¶é—´é™åˆ¶ï¼ˆç§’ï¼‰
  explanation String?  // è§£æ
  tags        Json?    // æ ‡ç­¾æ•°ç»„
  metadata    Json?    // æ‰©å±•å­—æ®µ
  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // å…³è”å…³ç³»
  createdBy     User            @relation(fields: [createdById], references: [id])
  options       QuestionOption[]
  examQuestions ExamQuestion[]
  answers       Answer[]
  
  @@index([type])
  @@index([difficulty])
  @@index([createdById])
}

// é¢˜ç›®é€‰é¡¹è¡¨ï¼ˆç”¨äºé€‰æ‹©é¢˜ï¼‰
model QuestionOption {
  id         String  @id @default(uuid())
  questionId String
  content    String
  isCorrect  Boolean @default(false)
  order      Int     @default(0)
  explanation String?
  
  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  
  @@index([questionId])
}

// è€ƒè¯•è¡¨
model Exam {
  id           String     @id @default(uuid())
  title        String
  description  String?
  type         ExamType   @default(PRACTICE)
  status       ExamStatus @default(DRAFT)
  timeLimit    Int?       // è€ƒè¯•æ—¶é—´é™åˆ¶ï¼ˆåˆ†é’Ÿï¼‰
  totalPoints  Int        @default(0)
  passingScore Int?       // åŠæ ¼åˆ†æ•°
  maxAttempts  Int        @default(1)
  startTime    DateTime?  // è€ƒè¯•å¼€å§‹æ—¶é—´
  endTime      DateTime?  // è€ƒè¯•ç»“æŸæ—¶é—´
  settings     Json?      // è€ƒè¯•è®¾ç½®
  createdById  String
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  
  // å…³è”å…³ç³»
  createdBy     User           @relation(fields: [createdById], references: [id])
  questions     ExamQuestion[]
  records       ExamRecord[]
  
  @@index([type])
  @@index([status])
  @@index([createdById])
}

// è€ƒè¯•é¢˜ç›®å…³è”è¡¨
model ExamQuestion {
  id         String @id @default(uuid())
  examId     String
  questionId String
  order      Int    @default(0)
  points     Int    @default(1)
  
  exam     Exam     @relation(fields: [examId], references: [id], onDelete: Cascade)
  question Question @relation(fields: [questionId], references: [id])
  
  @@unique([examId, questionId])
  @@index([examId])
}

// è€ƒè¯•è®°å½•è¡¨
model ExamRecord {
  id           String       @id @default(uuid())
  examId       String
  userId       String
  status       RecordStatus @default(IN_PROGRESS)
  score        Float?       // æ€»åˆ†
  totalPoints  Int          @default(0)
  startedAt    DateTime     @default(now())
  submittedAt  DateTime?
  timeSpent    Int?         // ç”¨æ—¶ï¼ˆç§’ï¼‰
  ipAddress    String?
  userAgent    String?
  metadata     Json?        // è€ƒè¯•è¿‡ç¨‹æ•°æ®
  
  // å…³è”å…³ç³»
  exam    Exam     @relation(fields: [examId], references: [id])
  user    User     @relation(fields: [userId], references: [id])
  answers Answer[]
  
  @@unique([examId, userId])
  @@index([examId])
  @@index([userId])
  @@index([status])
}

// ç­”æ¡ˆè®°å½•è¡¨
model Answer {
  id           String   @id @default(uuid())
  recordId     String
  questionId   String
  content      Json     // ç”¨æˆ·ç­”æ¡ˆ
  isCorrect    Boolean?
  score        Float?   // å¾—åˆ†
  timeSpent    Int?     // ç­”é¢˜ç”¨æ—¶ï¼ˆç§’ï¼‰
  submittedAt  DateTime @default(now())
  
  // å…³è”å…³ç³»
  record   ExamRecord @relation(fields: [recordId], references: [id], onDelete: Cascade)
  question Question   @relation(fields: [questionId], references: [id])
  
  @@unique([recordId, questionId])
  @@index([recordId])
}

// é¢˜ç›®æ ‡ç­¾è¡¨
model QuestionTag {
  id    String @id @default(uuid())
  name  String @unique
  color String @default("#3b82f6")
  
  @@index([name])
}

// è€ƒè¯•ç»Ÿè®¡è¡¨
model ExamStats {
  id            String   @id @default(uuid())
  examId        String   @unique
  totalAttempts Int      @default(0)
  avgScore      Float?
  maxScore      Float?
  minScore      Float?
  passRate      Float?   // é€šè¿‡ç‡
  updatedAt     DateTime @updatedAt
  
  exam Exam @relation(fields: [examId], references: [id])
}

// æšä¸¾å®šä¹‰
enum QuestionType {
  SINGLE_CHOICE    // å•é€‰é¢˜
  MULTIPLE_CHOICE  // å¤šé€‰é¢˜
  TRUE_FALSE       // åˆ¤æ–­é¢˜
  FILL_BLANK       // å¡«ç©ºé¢˜
  ESSAY           // ç®€ç­”é¢˜
}

enum DifficultyLevel {
  BEGINNER
  INTERMEDIATE  
  ADVANCED
}

enum ExamType {
  CHAPTER_TEST    // ç« èŠ‚æµ‹è¯•
  MOCK_EXAM      // æ¨¡æ‹Ÿè€ƒè¯•
  REAL_EXAM      // çœŸé¢˜è€ƒè¯•
  PRACTICE       // ç»ƒä¹ æ¨¡å¼
}

enum ExamStatus {
  DRAFT          // è‰ç¨¿
  PUBLISHED      // å·²å‘å¸ƒ
  ACTIVE         // è¿›è¡Œä¸­
  ENDED          // å·²ç»“æŸ
  CANCELLED      // å·²å–æ¶ˆ
}

enum RecordStatus {
  IN_PROGRESS    // è¿›è¡Œä¸­
  SUBMITTED      // å·²æäº¤
  GRADED        // å·²è¯„åˆ†
  EXPIRED       // å·²è¿‡æœŸ
}

// æ›´æ–°Useræ¨¡å‹ï¼Œæ·»åŠ è€ƒè¯•ç›¸å…³å…³è”
model User {
  // ... åŸæœ‰å­—æ®µ
  
  // æ–°å¢è€ƒè¯•ç›¸å…³å…³è”
  createdQuestions Question[]
  createdExams     Exam[]
  examRecords      ExamRecord[]
}
```

### åç«¯APIæ¥å£å®ç°

#### ã€backend/src/routes/questions.tsã€‘- æ–°å¢æ–‡ä»¶
```typescript
import { FastifyInstance } from 'fastify'
import { z } from 'zod'
import { authenticate, authorize } from '@/middlewares/auth'
import { validateBody, validateQuery, validateParams } from '@/middlewares/validation'
import { questionService } from '@/services/questionService'
import { logger } from '@/utils/logger'

const createQuestionSchema = z.object({
  title: z.string().min(1).max(200),
  content: z.any(), // Rich text content
  type: z.enum(['SINGLE_CHOICE', 'MULTIPLE_CHOICE', 'TRUE_FALSE', 'FILL_BLANK', 'ESSAY']),
  difficulty: z.enum(['BEGINNER', 'INTERMEDIATE', 'ADVANCED']).optional(),
  points: z.number().min(1).max(100).optional(),
  timeLimit: z.number().optional(),
  explanation: z.string().optional(),
  tags: z.array(z.string()).optional(),
  options: z.array(z.object({
    content: z.string(),
    isCorrect: z.boolean(),
    explanation: z.string().optional(),
  })).optional(),
})

const queryQuestionsSchema = z.object({
  page: z.coerce.number().min(1).optional().default(1),
  limit: z.coerce.number().min(1).max(100).optional().default(20),
  type: z.enum(['SINGLE_CHOICE', 'MULTIPLE_CHOICE', 'TRUE_FALSE', 'FILL_BLANK', 'ESSAY']).optional(),
  difficulty: z.enum(['BEGINNER', 'INTERMEDIATE', 'ADVANCED']).optional(),
  tag: z.string().optional(),
  search: z.string().optional(),
})

const batchImportSchema = z.object({
  questions: z.array(createQuestionSchema),
})

export const questionRoutes = async (app: FastifyInstance) => {
  // åˆ›å»ºé¢˜ç›®
  app.post('/', {
    preHandler: [authenticate, authorize(['TEACHER', 'ADMIN']), validateBody(createQuestionSchema)],
    schema: {
      description: 'Create a new question',
      tags: ['Questions'],
      security: [{ Bearer: [] }],
      body: {
        type: 'object',
        required: ['title', 'content', 'type'],
        properties: {
          title: { type: 'string' },
          content: { type: 'object' },
          type: { type: 'string', enum: ['SINGLE_CHOICE', 'MULTIPLE_CHOICE', 'TRUE_FALSE', 'FILL_BLANK', 'ESSAY'] },
          difficulty: { type: 'string', enum: ['BEGINNER', 'INTERMEDIATE', 'ADVANCED'] },
          points: { type: 'number' },
          timeLimit: { type: 'number' },
          explanation: { type: 'string' },
          tags: { type: 'array', items: { type: 'string' } },
          options: {
            type: 'array',
            items: {
              type: 'object',
              properties: {
                content: { type: 'string' },
                isCorrect: { type: 'boolean' },
                explanation: { type: 'string' },
              },
            },
          },
        },
      },
    },
  }, async (request, reply) => {
    const data = request.body as z.infer<typeof createQuestionSchema>
    const userId = request.user.userId

    try {
      const question = await questionService.createQuestion(userId, data)
      
      reply.send({
        success: true,
        message: 'é¢˜ç›®åˆ›å»ºæˆåŠŸ',
        data: question,
      })
    } catch (error: any) {
      logger.error('Create question error:', error)
      reply.code(500).send({
        success: false,
        error: 'Server Error',
        message: 'åˆ›å»ºé¢˜ç›®å¤±è´¥',
      })
    }
  })

  // è·å–é¢˜ç›®åˆ—è¡¨
  app.get('/', {
    preHandler: [authenticate, validateQuery(queryQuestionsSchema)],
    schema: {
      description: 'Get questions list',
      tags: ['Questions'],
      security: [{ Bearer: [] }],
      querystring: {
        type: 'object',
        properties: {
          page: { type: 'number' },
          limit: { type: 'number' },
          type: { type: 'string' },
          difficulty: { type: 'string' },
          tag: { type: 'string' },
          search: { type: 'string' },
        },
      },
    },
  }, async (request, reply) => {
    const params = request.query as z.infer<typeof queryQuestionsSchema>

    try {
      const result = await questionService.getQuestions(params)
      
      reply.send({
        success: true,
        data: result,
      })
    } catch (error: any) {
      logger.error('Get questions error:', error)
      reply.code(500).send({
        success: false,
        error: 'Server Error',
        message: 'è·å–é¢˜ç›®åˆ—è¡¨å¤±è´¥',
      })
    }
  })

  // è·å–å•ä¸ªé¢˜ç›®è¯¦æƒ…
  app.get('/:id', {
    preHandler: [authenticate, validateParams(z.object({ id: z.string().uuid() }))],
    schema: {
      description: 'Get question details',
      tags: ['Questions'],
      security: [{ Bearer: [] }],
      params: {
        type: 'object',
        properties: {
          id: { type: 'string', format: 'uuid' },
        },
      },
    },
  }, async (request, reply) => {
    const { id } = request.params as { id: string }

    try {
      const question = await questionService.getQuestionById(id)
      
      if (!question) {
        return reply.code(404).send({
          success: false,
          error: 'Not Found',
          message: 'é¢˜ç›®ä¸å­˜åœ¨',
        })
      }

      reply.send({
        success: true,
        data: question,
      })
    } catch (error: any) {
      logger.error('Get question error:', error)
      reply.code(500).send({
        success: false,
        error: 'Server Error',
        message: 'è·å–é¢˜ç›®è¯¦æƒ…å¤±è´¥',
      })
    }
  })

  // æ›´æ–°é¢˜ç›®
  app.put('/:id', {
    preHandler: [
      authenticate,
      authorize(['TEACHER', 'ADMIN']),
      validateParams(z.object({ id: z.string().uuid() })),
      validateBody(createQuestionSchema.partial()),
    ],
    schema: {
      description: 'Update question',
      tags: ['Questions'],
      security: [{ Bearer: [] }],
    },
  }, async (request, reply) => {
    const { id } = request.params as { id: string }
    const data = request.body as Partial<z.infer<typeof createQuestionSchema>>
    const userId = request.user.userId

    try {
      const question = await questionService.updateQuestion(id, userId, data)
      
      reply.send({
        success: true,
        message: 'é¢˜ç›®æ›´æ–°æˆåŠŸ',
        data: question,
      })
    } catch (error: any) {
      logger.error('Update question error:', error)
      
      if (error.message === 'Question not found') {
        return reply.code(404).send({
          success: false,
          error: 'Not Found',
          message: 'é¢˜ç›®ä¸å­˜åœ¨',
        })
      }
      
      if (error.message === 'Access denied') {
        return reply.code(403).send({
          success: false,
          error: 'Forbidden',
          message: 'æ— æƒé™ä¿®æ”¹æ­¤é¢˜ç›®',
        })
      }

      reply.code(500).send({
        success: false,
        error: 'Server Error',
        message: 'æ›´æ–°é¢˜ç›®å¤±è´¥',
      })
    }
  })

  // åˆ é™¤é¢˜ç›®
  app.delete('/:id', {
    preHandler: [
      authenticate,
      authorize(['TEACHER', 'ADMIN']),
      validateParams(z.object({ id: z.string().uuid() })),
    ],
    schema: {
      description: 'Delete question',
      tags: ['Questions'],
      security: [{ Bearer: [] }],
    },
  }, async (request, reply) => {
    const { id } = request.params as { id: string }
    const userId = request.user.userId

    try {
      await questionService.deleteQuestion(id, userId)
      
      reply.send({
        success: true,
        message: 'é¢˜ç›®åˆ é™¤æˆåŠŸ',
      })
    } catch (error: any) {
      logger.error('Delete question error:', error)
      
      if (error.message === 'Question not found') {
        return reply.code(404).send({
          success: false,
          error: 'Not Found',
          message: 'é¢˜ç›®ä¸å­˜åœ¨',
        })
      }
      
      if (error.message === 'Access denied') {
        return reply.code(403).send({
          success: false,
          error: 'Forbidden',
          message: 'æ— æƒé™åˆ é™¤æ­¤é¢˜ç›®',
        })
      }

      reply.code(500).send({
        success: false,
        error: 'Server Error',
        message: 'åˆ é™¤é¢˜ç›®å¤±è´¥',
      })
    }
  })

  // æ‰¹é‡å¯¼å…¥é¢˜ç›®
  app.post('/batch-import', {
    preHandler: [
      authenticate,
      authorize(['TEACHER', 'ADMIN']),
      validateBody(batchImportSchema),
    ],
    schema: {
      description: 'Batch import questions',
      tags: ['Questions'],
      security: [{ Bearer: [] }],
    },
  }, async (request, reply) => {
    const { questions } = request.body as z.infer<typeof batchImportSchema>
    const userId = request.user.userId

    try {
      const result = await questionService.batchImportQuestions(userId, questions)
      
      reply.send({
        success: true,
        message: 'é¢˜ç›®æ‰¹é‡å¯¼å…¥æˆåŠŸ',
        data: result,
      })
    } catch (error: any) {
      logger.error('Batch import error:', error)
      reply.code(500).send({
        success: false,
        error: 'Server Error',
        message: 'æ‰¹é‡å¯¼å…¥å¤±è´¥',
      })
    }
  })

  // è·å–é¢˜ç›®ç»Ÿè®¡
  app.get('/stats/overview', {
    preHandler: [authenticate],
    schema: {
      description: 'Get questions statistics',
      tags: ['Questions'],
      security: [{ Bearer: [] }],
    },
  }, async (request, reply) => {
    try {
      const stats = await questionService.getQuestionStats()
      
      reply.send({
        success: true,
        data: stats,
      })
    } catch (error: any) {
      logger.error('Get question stats error:', error)
      reply.code(500).send({
        success: false,
        error: 'Server Error',
        message: 'è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥',
      })
    }
  })
}
```

#### ã€backend/src/routes/exams.tsã€‘- æ–°å¢æ–‡ä»¶
```typescript
import { FastifyInstance } from 'fastify'
import { z } from 'zod'
import { authenticate, authorize } from '@/middlewares/auth'
import { validateBody, validateQuery, validateParams } from '@/middlewares/validation'
import { examService } from '@/services/examService'
import { logger } from '@/utils/logger'

const createExamSchema = z.object({
  title: z.string().min(1).max(200),
  description: z.string().optional(),
  type: z.enum(['CHAPTER_TEST', 'MOCK_EXAM', 'REAL_EXAM', 'PRACTICE']),
  timeLimit: z.number().optional(),
  passingScore: z.number().optional(),
  maxAttempts: z.number().min(1).optional(),
  startTime: z.string().datetime().optional(),
  endTime: z.string().datetime().optional(),
  settings: z.any().optional(),
  questionIds: z.array(z.string().uuid()).min(1),
})

const queryExamsSchema = z.object({
  page: z.coerce.number().min(1).optional().default(1),
  limit: z.coerce.number().min(1).max(100).optional().default(20),
  type: z.enum(['CHAPTER_TEST', 'MOCK_EXAM', 'REAL_EXAM', 'PRACTICE']).optional(),
  status: z.enum(['DRAFT', 'PUBLISHED', 'ACTIVE', 'ENDED', 'CANCELLED']).optional(),
  search: z.string().optional(),
})

const submitAnswerSchema = z.object({
  questionId: z.string().uuid(),
  content: z.any(), // ç­”æ¡ˆå†…å®¹ï¼Œæ”¯æŒå¤šç§æ ¼å¼
  timeSpent: z.number().optional(),
})

const batchSubmitSchema = z.object({
  answers: z.array(submitAnswerSchema),
})

export const examRoutes = async (app: FastifyInstance) => {
  // åˆ›å»ºè€ƒè¯•
  app.post('/', {
    preHandler: [authenticate, authorize(['TEACHER', 'ADMIN']), validateBody(createExamSchema)],
    schema: {
      description: 'Create a new exam',
      tags: ['Exams'],
      security: [{ Bearer: [] }],
    },
  }, async (request, reply) => {
    const data = request.body as z.infer<typeof createExamSchema>
    const userId = request.user.userId

    try {
      const exam = await examService.createExam(userId, data)
      
      reply.send({
        success: true,
        message: 'è€ƒè¯•åˆ›å»ºæˆåŠŸ',
        data: exam,
      })
    } catch (error: any) {
      logger.error('Create exam error:', error)
      reply.code(500).send({
        success: false,
        error: 'Server Error',
        message: 'åˆ›å»ºè€ƒè¯•å¤±è´¥',
      })
    }
  })

  // è·å–è€ƒè¯•åˆ—è¡¨
  app.get('/', {
    preHandler: [authenticate, validateQuery(queryExamsSchema)],
    schema: {
      description: 'Get exams list',
      tags: ['Exams'],
      security: [{ Bearer: [] }],
    },
  }, async (request, reply) => {
    const params = request.query as z.infer<typeof queryExamsSchema>
    const userId = request.user.userId
    const userRole = request.user.role

    try {
      const result = await examService.getExams(userId, userRole, params)
      
      reply.send({
        success: true,
        data: result,
      })
    } catch (error: any) {
      logger.error('Get exams error:', error)
      reply.code(500).send({
        success: false,
        error: 'Server Error',
        message: 'è·å–è€ƒè¯•åˆ—è¡¨å¤±è´¥',
      })
    }
  })

  // è·å–è€ƒè¯•è¯¦æƒ…
  app.get('/:id', {
    preHandler: [authenticate, validateParams(z.object({ id: z.string().uuid() }))],
    schema: {
      description: 'Get exam details',
      tags: ['Exams'],
      security: [{ Bearer: [] }],
    },
  }, async (request, reply) => {
    const { id } = request.params as { id: string }
    const userId = request.user.userId

    try {
      const exam = await examService.getExamById(id, userId)
      
      if (!exam) {
        return reply.code(404).send({
          success: false,
          error: 'Not Found',
          message: 'è€ƒè¯•ä¸å­˜åœ¨',
        })
      }

      reply.send({
        success: true,
        data: exam,
      })
    } catch (error: any) {
      logger.error('Get exam error:', error)
      reply.code(500).send({
        success: false,
        error: 'Server Error',
        message: 'è·å–è€ƒè¯•è¯¦æƒ…å¤±è´¥',
      })
    }
  })

  // å¼€å§‹è€ƒè¯•
  app.post('/:id/start', {
    preHandler: [authenticate, validateParams(z.object({ id: z.string().uuid() }))],
    schema: {
      description: 'Start exam',
      tags: ['Exams'],
      security: [{ Bearer: [] }],
    },
  }, async (request, reply) => {
    const { id } = request.params as { id: string }
    const userId = request.user.userId
    const ipAddress = request.ip
    const userAgent = request.headers['user-agent']

    try {
      const examRecord = await examService.startExam(id, userId, {
        ipAddress,
        userAgent,
      })
      
      reply.send({
        success: true,
        message: 'è€ƒè¯•å¼€å§‹',
        data: examRecord,
      })
    } catch (error: any) {
      logger.error('Start exam error:', error)
      
      if (error.message === 'Exam not found') {
        return reply.code(404).send({
          success: false,
          error: 'Not Found',
          message: 'è€ƒè¯•ä¸å­˜åœ¨',
        })
      }
      
      if (error.message === 'Exam not available') {
        return reply.code(400).send({
          success: false,
          error: 'Bad Request',
          message: 'è€ƒè¯•å½“å‰ä¸å¯ç”¨',
        })
      }
      
      if (error.message === 'Max attempts exceeded') {
        return reply.code(400).send({
          success: false,
          error: 'Bad Request',
          message: 'å·²è¶…è¿‡æœ€å¤§å°è¯•æ¬¡æ•°',
        })
      }

      reply.code(500).send({
        success: false,
        error: 'Server Error',
        message: 'å¼€å§‹è€ƒè¯•å¤±è´¥',
      })
    }
  })

  // æäº¤å•ä¸ªç­”æ¡ˆ
  app.post('/:id/answer', {
    preHandler: [authenticate, validateParams(z.object({ id: z.string().uuid() })), validateBody(submitAnswerSchema)],
    schema: {
      description: 'Submit answer for a question',
      tags: ['Exams'],
      security: [{ Bearer: [] }],
    },
  }, async (request, reply) => {
    const { id } = request.params as { id: string }
    const answerData = request.body as z.infer<typeof submitAnswerSchema>
    const userId = request.user.userId

    try {
      const answer = await examService.submitAnswer(id, userId, answerData)
      
      reply.send({
        success: true,
        message: 'ç­”æ¡ˆæäº¤æˆåŠŸ',
        data: answer,
      })
    } catch (error: any) {
      logger.error('Submit answer error:', error)
      reply.code(500).send({
        success: false,
        error: 'Server Error',
        message: 'æäº¤ç­”æ¡ˆå¤±è´¥',
      })
    }
  })

  // æ‰¹é‡æäº¤ç­”æ¡ˆ
  app.post('/:id/batch-answer', {
    preHandler: [authenticate, validateParams(z.object({ id: z.string().uuid() })), validateBody(batchSubmitSchema)],
    schema: {
      description: 'Batch submit answers',
      tags: ['Exams'],
      security: [{ Bearer: [] }],
    },
  }, async (request, reply) => {
    const { id } = request.params as { id: string }
    const { answers } = request.body as z.infer<typeof batchSubmitSchema>
    const userId = request.user.userId

    try {
      const result = await examService.batchSubmitAnswers(id, userId, answers)
      
      reply.send({
        success: true,
        message: 'ç­”æ¡ˆæ‰¹é‡æäº¤æˆåŠŸ',
        data: result,
      })
    } catch (error: any) {
      logger.error('Batch submit answers error:', error)
      reply.code(500).send({
        success: false,
        error: 'Server Error',
        message: 'æ‰¹é‡æäº¤ç­”æ¡ˆå¤±è´¥',
      })
    }
  })

  // å®Œæˆè€ƒè¯•
  app.post('/:id/finish', {
    preHandler: [authenticate, validateParams(z.object({ id: z.string().uuid() }))],
    schema: {
      description: 'Finish exam',
      tags: ['Exams'],
      security: [{ Bearer: [] }],
    },
  }, async (request, reply) => {
    const { id } = request.params as { id: string }
    const userId = request.user.userId

    try {
      const result = await examService.finishExam(id, userId)
      
      reply.send({
        success: true,
        message: 'è€ƒè¯•å®Œæˆ',
        data: result,
      })
    } catch (error: any) {
      logger.error('Finish exam error:', error)
      reply.code(500).send({
        success: false,
        error: 'Server Error',
        message: 'å®Œæˆè€ƒè¯•å¤±è´¥',
      })
    }
  })

  // è·å–è€ƒè¯•ç»“æœ
  app.get('/:id/result', {
    preHandler: [authenticate, validateParams(z.object({ id: z.string().uuid() }))],
    schema: {
      description: 'Get exam result',
      tags: ['Exams'],
      security: [{ Bearer: [] }],
    },
  }, async (request, reply) => {
    const { id } = request.params as { id: string }
    const userId = request.user.userId

    try {
      const result = await examService.getExamResult(id, userId)
      
      if (!result) {
        return reply.code(404).send({
          success: false,
          error: 'Not Found',
          message: 'è€ƒè¯•è®°å½•ä¸å­˜åœ¨',
        })
      }

      reply.send({
        success: true,
        data: result,
      })
    } catch (error: any) {
      logger.error('Get exam result error:', error)
      reply.code(500).send({
        success: false,
        error: 'Server Error',
        message: 'è·å–è€ƒè¯•ç»“æœå¤±è´¥',
      })
    }
  })

  // è·å–è€ƒè¯•ç»Ÿè®¡
  app.get('/:id/stats', {
    preHandler: [authenticate, authorize(['TEACHER', 'ADMIN']), validateParams(z.object({ id: z.string().uuid() }))],
    schema: {
      description: 'Get exam statistics',
      tags: ['Exams'],
      security: [{ Bearer: [] }],
    },
  }, async (request, reply) => {
    const { id } = request.params as { id: string }

    try {
      const stats = await examService.getExamStats(id)
      
      reply.send({
        success: true,
        data: stats,
      })
    } catch (error: any) {
      logger.error('Get exam stats error:', error)
      reply.code(500).send({
        success: false,
        error: 'Server Error',
        message: 'è·å–è€ƒè¯•ç»Ÿè®¡å¤±è´¥',
      })
    }
  })

  // å‘å¸ƒè€ƒè¯•
  app.post('/:id/publish', {
    preHandler: [authenticate, authorize(['TEACHER', 'ADMIN']), validateParams(z.object({ id: z.string().uuid() }))],
    schema: {
      description: 'Publish exam',
      tags: ['Exams'],
      security: [{ Bearer: [] }],
    },
  }, async (request, reply) => {
    const { id } = request.params as { id: string }
    const userId = request.user.userId

    try {
      const exam = await examService.publishExam(id, userId)
      
      reply.send({
        success: true,
        message: 'è€ƒè¯•å‘å¸ƒæˆåŠŸ',
        data: exam,
      })
    } catch (error: any) {
      logger.error('Publish exam error:', error)
      reply.code(500).send({
        success: false,
        error: 'Server Error',
        message: 'å‘å¸ƒè€ƒè¯•å¤±è´¥',
      })
    }
  })
}
```

### ä¸šåŠ¡é€»è¾‘æœåŠ¡å±‚

#### ã€backend/src/services/questionService.tsã€‘- æ–°å¢æ–‡ä»¶
```typescript
import { prisma } from '@/config/database'
import { cache } from '@/config/redis'
import { logger } from '@/utils/logger'
import { v4 as uuidv4 } from 'uuid'

interface CreateQuestionData {
  title: string
  content: any
  type: string
  difficulty?: string
  points?: number
  timeLimit?: number
  explanation?: string
  tags?: string[]
  options?: Array<{
    content: string
    isCorrect: boolean
    explanation?: string
  }>
}

interface QueryQuestionsParams {
  page: number
  limit: number
  type?: string
  difficulty?: string
  tag?: string
  search?: string
}

export const questionService = {
  async createQuestion(userId: string, data: CreateQuestionData) {
    const questionId = uuidv4()
    
    // åˆ›å»ºé¢˜ç›®
    const question = await prisma.question.create({
      data: {
        id: questionId,
        title: data.title,
        content: data.content,
        type: data.type as any,
        difficulty: (data.difficulty as any) || 'INTERMEDIATE',
        points: data.points || 1,
        timeLimit: data.timeLimit,
        explanation: data.explanation,
        tags: data.tags || [],
        createdById: userId,
      },
    })

    // åˆ›å»ºé€‰é¡¹ï¼ˆå¦‚æœæ˜¯é€‰æ‹©é¢˜ï¼‰
    if (data.options && data.options.length > 0) {
      await prisma.questionOption.createMany({
        data: data.options.map((option, index) => ({
          id: uuidv4(),
          questionId: question.id,
          content: option.content,
          isCorrect: option.isCorrect,
          order: index,
          explanation: option.explanation,
        })),
      })
    }

    // è·å–å®Œæ•´çš„é¢˜ç›®ä¿¡æ¯
    const fullQuestion = await this.getQuestionById(question.id)
    
    // æ¸…é™¤ç›¸å…³ç¼“å­˜
    await cache.invalidatePattern('questions:*')
    
    logger.info(`Question created: ${question.id} by user ${userId}`)
    
    return fullQuestion
  },

  async getQuestions(params: QueryQuestionsParams) {
    const { page, limit, type, difficulty, tag, search } = params
    const skip = (page - 1) * limit

    // æ„å»ºç¼“å­˜é”®
    const cacheKey = `questions:list:${JSON.stringify(params)}`
    const cached = await cache.get(cacheKey)
    if (cached) {
      return cached
    }

    // æ„å»ºæŸ¥è¯¢æ¡ä»¶
    const where: any = {}

    if (type) {
      where.type = type
    }

    if (difficulty) {
      where.difficulty = difficulty
    }

    if (tag) {
      where.tags = {
        path: '$[*]',
        string_contains: tag,
      }
    }

    if (search) {
      where.OR = [
        { title: { contains: search, mode: 'insensitive' } },
        { explanation: { contains: search, mode: 'insensitive' } },
      ]
    }

    const [questions, total] = await Promise.all([
      prisma.question.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: 'desc' },
        include: {
          options: {
            orderBy: { order: 'asc' },
          },
          createdBy: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
          _count: {
            select: {
              examQuestions: true,
              answers: true,
            },
          },
        },
      }),
      prisma.question.count({ where }),
    ])

    const result = {
      questions,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    }

    // ç¼“å­˜ç»“æœ
    await cache.set(cacheKey, result, 300) // 5åˆ†é’Ÿç¼“å­˜

    return result
  },

  async getQuestionById(id: string) {
    const cacheKey = `question:${id}`
    const cached = await cache.get(cacheKey)
    if (cached) {
      return cached
    }

    const question = await prisma.question.findUnique({
      where: { id },
      include: {
        options: {
          orderBy: { order: 'asc' },
        },
        createdBy: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
        _count: {
          select: {
            examQuestions: true,
            answers: true,
          },
        },
      },
    })

    if (question) {
      await cache.set(cacheKey, question, 3600) // 1å°æ—¶ç¼“å­˜
    }

    return question
  },

  async updateQuestion(id: string, userId: string, data: Partial<CreateQuestionData>) {
    // æ£€æŸ¥æƒé™
    const existingQuestion = await prisma.question.findUnique({
      where: { id },
      select: { createdById: true },
    })

    if (!existingQuestion) {
      throw new Error('Question not found')
    }

    if (existingQuestion.createdById !== userId) {
      throw new Error('Access denied')
    }

    // æ›´æ–°é¢˜ç›®
    const question = await prisma.question.update({
      where: { id },
      data: {
        title: data.title,
        content: data.content,
        type: data.type as any,
        difficulty: data.difficulty as any,
        points: data.points,
        timeLimit: data.timeLimit,
        explanation: data.explanation,
        tags: data.tags,
        updatedAt: new Date(),
      },
    })

    // æ›´æ–°é€‰é¡¹
    if (data.options) {
      // åˆ é™¤æ—§é€‰é¡¹
      await prisma.questionOption.deleteMany({
        where: { questionId: id },
      })

      // åˆ›å»ºæ–°é€‰é¡¹
      if (data.options.length > 0) {
        await prisma.questionOption.createMany({
          data: data.options.map((option, index) => ({
            id: uuidv4(),
            questionId: id,
            content: option.content,
            isCorrect: option.isCorrect,
            order: index,
            explanation: option.explanation,
          })),
        })
      }
    }

    // æ¸…é™¤ç¼“å­˜
    await cache.del(`question:${id}`)
    await cache.invalidatePattern('questions:*')

    return this.getQuestionById(id)
  },

  async deleteQuestion(id: string, userId: string) {
    // æ£€æŸ¥æƒé™
    const existingQuestion = await prisma.question.findUnique({
      where: { id },
      select: { 
        createdById: true,
        _count: {
          select: {
            examQuestions: true,
          },
        },
      },
    })

    if (!existingQuestion) {
      throw new Error('Question not found')
    }

    if (existingQuestion.createdById !== userId) {
      throw new Error('Access denied')
    }

    // æ£€æŸ¥æ˜¯å¦è¢«è€ƒè¯•ä½¿ç”¨
    if (existingQuestion._count.examQuestions > 0) {
      throw new Error('Question is being used in exams')
    }

    // åˆ é™¤é¢˜ç›®ï¼ˆçº§è”åˆ é™¤é€‰é¡¹ï¼‰
    await prisma.question.delete({
      where: { id },
    })

    // æ¸…é™¤ç¼“å­˜
    await cache.del(`question:${id}`)
    await cache.invalidatePattern('questions:*')

    logger.info(`Question deleted: ${id} by user ${userId}`)
  },

  async batchImportQuestions(userId: string, questions: CreateQuestionData[]) {
    const results = {
      success: 0,
      failed: 0,
      errors: [] as string[],
    }

    for (const questionData of questions) {
      try {
        await this.createQuestion(userId, questionData)
        results.success++
      } catch (error: any) {
        results.failed++
        results.errors.push(`é¢˜ç›® "${questionData.title}": ${error.message}`)
      }
    }

    return results
  },

  async getQuestionStats() {
    const cacheKey = 'questions:stats'
    const cached = await cache.get(cacheKey)
    if (cached) {
      return cached
    }

    const [
      totalQuestions,
      questionsByType,
      questionsByDifficulty,
      recentQuestions,
    ] = await Promise.all([
      prisma.question.count(),
      prisma.question.groupBy({
        by: ['type'],
        _count: { id: true },
      }),
      prisma.question.groupBy({
        by: ['difficulty'],
        _count: { id: true },
      }),
      prisma.question.count({
        where: {
          createdAt: {
            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), // æœ€è¿‘7å¤©
          },
        },
      }),
    ])

    const stats = {
      totalQuestions,
      questionsByType: questionsByType.reduce((acc, item) => {
        acc[item.type] = item._count.id
        return acc
      }, {} as Record<string, number>),
      questionsByDifficulty: questionsByDifficulty.reduce((acc, item) => {
        acc[item.difficulty] = item._count.id
        return acc
      }, {} as Record<string, number>),
      recentQuestions,
    }

    await cache.set(cacheKey, stats, 3600) // 1å°æ—¶ç¼“å­˜
    return stats
  },

  // è·å–éšæœºé¢˜ç›®ï¼ˆç”¨äºç”Ÿæˆç»ƒä¹ ï¼‰
  async getRandomQuestions(params: {
    count: number
    type?: string
    difficulty?: string
    excludeIds?: string[]
  }) {
    const { count, type, difficulty, excludeIds = [] } = params

    const where: any = {}

    if (type) {
      where.type = type
    }

    if (difficulty) {
      where.difficulty = difficulty
    }

    if (excludeIds.length > 0) {
      where.id = {
        notIn: excludeIds,
      }
    }

    // å…ˆè·å–ç¬¦åˆæ¡ä»¶çš„é¢˜ç›®æ€»æ•°
    const totalCount = await prisma.question.count({ where })
    
    if (totalCount === 0) {
      return []
    }

    // éšæœºé€‰æ‹©é¢˜ç›®
    const skip = Math.floor(Math.random() * Math.max(1, totalCount - count))
    
    const questions = await prisma.question.findMany({
      where,
      skip: skip,
      take: count,
      include: {
        options: {
          orderBy: { order: 'asc' },
        },
      },
    })

    return questions
  },
}
```

#### ã€backend/src/services/examService.tsã€‘- æ–°å¢æ–‡ä»¶
```typescript
import { prisma } from '@/config/database'
import { cache } from '@/config/redis'
import { logger } from '@/utils/logger'
import { aiService } from '@/config/ai'
import { v4 as uuidv4 } from 'uuid'

interface CreateExamData {
  title: string
  description?: string
  type: string
  timeLimit?: number
  passingScore?: number
  maxAttempts?: number
  startTime?: string
  endTime?: string
  settings?: any
  questionIds: string[]
}

interface QueryExamsParams {
  page: number
  limit: number
  type?: string
  status?: string
  search?: string
}

interface SubmitAnswerData {
  questionId: string
  content: any
  timeSpent?: number
}

export const examService = {
  async createExam(userId: string, data: CreateExamData) {
    // éªŒè¯é¢˜ç›®æ˜¯å¦å­˜åœ¨
    const questions = await prisma.question.findMany({
      where: {
        id: { in: data.questionIds },
      },
      select: { id: true, points: true },
    })

    if (questions.length !== data.questionIds.length) {
      throw new Error('Some questions not found')
    }

    const totalPoints = questions.reduce((sum, q) => sum + q.points, 0)

    // åˆ›å»ºè€ƒè¯•
    const exam = await prisma.exam.create({
      data: {
        title: data.title,
        description: data.description,
        type: data.type as any,
        timeLimit: data.timeLimit,
        totalPoints,
        passingScore: data.passingScore,
        maxAttempts: data.maxAttempts || 1,
        startTime: data.startTime ? new Date(data.startTime) : null,
        endTime: data.endTime ? new Date(data.endTime) : null,
        settings: data.settings,
        createdById: userId,
      },
    })

    // å…³è”é¢˜ç›®
    await prisma.examQuestion.createMany({
      data: data.questionIds.map((questionId, index) => ({
        id: uuidv4(),
        examId: exam.id,
        questionId,
        order: index,
        points: questions.find(q => q.id === questionId)?.points || 1,
      })),
    })

    // åˆ›å»ºç»Ÿè®¡è®°å½•
    await prisma.examStats.create({
      data: {
        examId: exam.id,
      },
    })

    logger.info(`Exam created: ${exam.id} by user ${userId}`)
    return this.getExamById(exam.id, userId)
  },

  async getExams(userId: string, userRole: string, params: QueryExamsParams) {
    const { page, limit, type, status, search } = params
    const skip = (page - 1) * limit

    // æ„å»ºæŸ¥è¯¢æ¡ä»¶
    const where: any = {}

    // å­¦ç”Ÿåªèƒ½çœ‹åˆ°å·²å‘å¸ƒçš„è€ƒè¯•
    if (userRole === 'STUDENT') {
      where.status = 'PUBLISHED'
    }

    if (type) {
      where.type = type
    }

    if (status) {
      where.status = status
    }

    if (search) {
      where.OR = [
        { title: { contains: search, mode: 'insensitive' } },
        { description: { contains: search, mode: 'insensitive' } },
      ]
    }

    const [exams, total] = await Promise.all([
      prisma.exam.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: 'desc' },
        include: {
          createdBy: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
          _count: {
            select: {
              questions: true,
              records: true,
            },
          },
          // å¦‚æœæ˜¯å­¦ç”Ÿï¼Œè·å–è€ƒè¯•è®°å½•
          ...(userRole === 'STUDENT' && {
            records: {
              where: { userId },
              select: {
                id: true,
                status: true,
                score: true,
                submittedAt: true,
              },
            },
          }),
        },
      }),
      prisma.exam.count({ where }),
    ])

    return {
      exams,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    }
  },

  async getExamById(id: string, userId?: string) {
    const exam = await prisma.exam.findUnique({
      where: { id },
      include: {
        createdBy: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
        questions: {
          orderBy: { order: 'asc' },
          include: {
            question: {
              include: {
                options: {
                  orderBy: { order: 'asc' },
                },
              },
            },
          },
        },
        _count: {
          select: {
            records: true,
          },
        },
        ...(userId && {
          records: {
            where: { userId },
            orderBy: { startedAt: 'desc' },
            take: 1,
          },
        }),
      },
    })

    return exam
  },

  async startExam(examId: string, userId: string, metadata: any) {
    // è·å–è€ƒè¯•ä¿¡æ¯
    const exam = await prisma.exam.findUnique({
      where: { id: examId },
      include: {
        _count: {
          select: {
            records: {
              where: { userId },
            },
          },
        },
      },
    })

    if (!exam) {
      throw new Error('Exam not found')
    }

    // æ£€æŸ¥è€ƒè¯•çŠ¶æ€
    if (exam.status !== 'PUBLISHED') {
      throw new Error('Exam not available')
    }

    // æ£€æŸ¥æ—¶é—´é™åˆ¶
    const now = new Date()
    if (exam.startTime && now < exam.startTime) {
      throw new Error('Exam not started yet')
    }
    if (exam.endTime && now > exam.endTime) {
      throw new Error('Exam has ended')
    }

    // æ£€æŸ¥å°è¯•æ¬¡æ•°
    if (exam._count.records >= exam.maxAttempts) {
      throw new Error('Max attempts exceeded')
    }

    // æ£€æŸ¥æ˜¯å¦æœ‰è¿›è¡Œä¸­çš„è€ƒè¯•
    const existingRecord = await prisma.examRecord.findFirst({
      where: {
        examId,
        userId,
        status: 'IN_PROGRESS',
      },
    })

    if (existingRecord) {
      return existingRecord
    }

    // åˆ›å»ºè€ƒè¯•è®°å½•
    const examRecord = await prisma.examRecord.create({
      data: {
        examId,
        userId,
        totalPoints: exam.totalPoints,
        ipAddress: metadata.ipAddress,
        userAgent: metadata.userAgent,
        metadata: {
          startTime: now.toISOString(),
        },
      },
    })

    // æ¸…é™¤ç›¸å…³ç¼“å­˜
    await cache.del(`exam:${examId}:user:${userId}`)

    logger.info(`Exam started: ${examId} by user ${userId}`)
    return examRecord
  },

  async submitAnswer(examId: string, userId: string, answerData: SubmitAnswerData) {
    // è·å–è€ƒè¯•è®°å½•
    const examRecord = await prisma.examRecord.findFirst({
      where: {
        examId,
        userId,
        status: 'IN_PROGRESS',
      },
    })

    if (!examRecord) {
      throw new Error('No active exam record found')
    }

    // è·å–é¢˜ç›®ä¿¡æ¯
    const question = await prisma.question.findUnique({
      where: { id: answerData.questionId },
      include: {
        options: true,
      },
    })

    if (!question) {
      throw new Error('Question not found')
    }

    // è¯„åˆ†
    const { isCorrect, score } = await this.gradeAnswer(question, answerData.content)

    // ä¿å­˜ç­”æ¡ˆ
    const answer = await prisma.answer.upsert({
      where: {
        recordId_questionId: {
          recordId: examRecord.id,
          questionId: answerData.questionId,
        },
      },
      update: {
        content: answerData.content,
        isCorrect,
        score,
        timeSpent: answerData.timeSpent,
        submittedAt: new Date(),
      },
      create: {
        recordId: examRecord.id,
        questionId: answerData.questionId,
        content: answerData.content,
        isCorrect,
        score,
        timeSpent: answerData.timeSpent,
      },
    })

    return answer
  },

  async batchSubmitAnswers(examId: string, userId: string, answers: SubmitAnswerData[]) {
    const results = []
    
    for (const answerData of answers) {
      try {
        const result = await this.submitAnswer(examId, userId, answerData)
        results.push(result)
      } catch (error: any) {
        logger.error(`Failed to submit answer for question ${answerData.questionId}:`, error)
        results.push({ error: error.message, questionId: answerData.questionId })
      }
    }

    return results
  },

  async finishExam(examId: string, userId: string) {
    // è·å–è€ƒè¯•è®°å½•
    const examRecord = await prisma.examRecord.findFirst({
      where: {
        examId,
        userId,
        status: 'IN_PROGRESS',
      },
      include: {
        answers: true,
        exam: true,
      },
    })

    if (!examRecord) {
      throw new Error('No active exam record found')
    }

    // è®¡ç®—æ€»åˆ†
    const totalScore = examRecord.answers.reduce((sum, answer) => sum + (answer.score || 0), 0)
    const timeSpent = Math.floor((new Date().getTime() - examRecord.startedAt.getTime()) / 1000)

    // æ›´æ–°è€ƒè¯•è®°å½•
    const finishedRecord = await prisma.examRecord.update({
      where: { id: examRecord.id },
      data: {
        status: 'SUBMITTED',
        score: totalScore,
        submittedAt: new Date(),
        timeSpent,
      },
    })

    // æ›´æ–°è€ƒè¯•ç»Ÿè®¡
    await this.updateExamStats(examId)

    // åˆ›å»ºå­¦ä¹ æ´»åŠ¨è®°å½•
    await prisma.learningActivity.create({
      data: {
        userId,
        type: 'QUIZ_TAKEN',
        title: 'å®Œæˆè€ƒè¯•',
        description: `å®Œæˆäº†è€ƒè¯•ï¼š${examRecord.exam.title}ï¼Œå¾—åˆ†ï¼š${totalScore}`,
        metadata: {
          examId,
          score: totalScore,
          totalPoints: examRecord.totalPoints,
        },
      },
    })

    logger.info(`Exam finished: ${examId} by user ${userId}, score: ${totalScore}`)
    return finishedRecord
  },

  async getExamResult(examId: string, userId: string) {
    const examRecord = await prisma.examRecord.findFirst({
      where: {
        examId,
        userId,
        status: { in: ['SUBMITTED', 'GRADED'] },
      },
      include: {
        exam: {
          select: {
            title: true,
            totalPoints: true,
            passingScore: true,
          },
        },
        answers: {
          include: {
            question: {
              select: {
                id: true,
                title: true,
                type: true,
                points: true,
                explanation: true,
              },
            },
          },
        },
      },
      orderBy: { submittedAt: 'desc' },
    })

    if (!examRecord) {
      return null
    }

    // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
    const correctAnswers = examRecord.answers.filter(a => a.isCorrect).length
    const totalQuestions = examRecord.answers.length
    const accuracy = totalQuestions > 0 ? (correctAnswers / totalQuestions) * 100 : 0
    const passed = examRecord.exam.passingScore 
      ? (examRecord.score || 0) >= examRecord.exam.passingScore 
      : null

    return {
      ...examRecord,
      statistics: {
        correctAnswers,
        totalQuestions,
        accuracy: Math.round(accuracy * 100) / 100,
        passed,
      },
    }
  },

  async getExamStats(examId: string) {
    const [examStats, records] = await Promise.all([
      prisma.examStats.findUnique({
        where: { examId },
      }),
      prisma.examRecord.findMany({
        where: {
          examId,
          status: { in: ['SUBMITTED', 'GRADED'] },
        },
        select: {
          score: true,
          timeSpent: true,
          submittedAt: true,
        },
      }),
    ])

    if (!examStats || records.length === 0) {
      return {
        totalAttempts: 0,
        avgScore: 0,
        maxScore: 0,
        minScore: 0,
        passRate: 0,
        avgTimeSpent: 0,
      }
    }

    const scores = records.map(r => r.score || 0)
    const timesSpent = records.map(r => r.timeSpent || 0).filter(t => t > 0)

    return {
      totalAttempts: records.length,
      avgScore: scores.reduce((sum, score) => sum + score, 0) / scores.length,
      maxScore: Math.max(...scores),
      minScore: Math.min(...scores),
      passRate: examStats.passRate || 0,
      avgTimeSpent: timesSpent.length > 0 
        ? timesSpent.reduce((sum, time) => sum + time, 0) / timesSpent.length 
        : 0,
    }
  },

  async publishExam(examId: string, userId: string) {
    // æ£€æŸ¥æƒé™
    const exam = await prisma.exam.findUnique({
      where: { id: examId },
      select: { createdById: true, status: true },
    })

    if (!exam) {
      throw new Error('Exam not found')
    }

    if (exam.createdById !== userId) {
      throw new Error('Access denied')
    }

    if (exam.status !== 'DRAFT') {
      throw new Error('Only draft exams can be published')
    }

    // å‘å¸ƒè€ƒè¯•
    const publishedExam = await prisma.exam.update({
      where: { id: examId },
      data: { status: 'PUBLISHED' },
    })

    logger.info(`Exam published: ${examId} by user ${userId}`)
    return publishedExam
  },

  // è¯„åˆ†é€»è¾‘
  async gradeAnswer(question: any, userAnswer: any): Promise<{ isCorrect: boolean; score: number }> {
    switch (question.type) {
      case 'SINGLE_CHOICE':
        return this.gradeSingleChoice(question, userAnswer)
      
      case 'MULTIPLE_CHOICE':
        return this.gradeMultipleChoice(question, userAnswer)
      
      case 'TRUE_FALSE':
        return this.gradeTrueFalse(question, userAnswer)
      
      case 'FILL_BLANK':
        return this.gradeFillBlank(question, userAnswer)
      
      case 'ESSAY':
        return await this.gradeEssay(question, userAnswer)
      
      default:
        return { isCorrect: false, score: 0 }
    }
  },

  gradeSingleChoice(question: any, userAnswer: any) {
    const correctOption = question.options.find((opt: any) => opt.isCorrect)
    const isCorrect = correctOption && userAnswer === correctOption.id
    return {
      isCorrect: !!isCorrect,
      score: isCorrect ? question.points : 0,
    }
  },

  gradeMultipleChoice(question: any, userAnswer: any) {
    const correctOptions = question.options.filter((opt: any) => opt.isCorrect).map((opt: any) => opt.id)
    const userOptions = Array.isArray(userAnswer) ? userAnswer : []
    
    const correctSelected = userOptions.filter((id: string) => correctOptions.includes(id))
    const incorrectSelected = userOptions.filter((id: string) => !correctOptions.includes(id))
    
    // éƒ¨åˆ†åˆ†æ•°è®¡ç®—
    const totalCorrect = correctOptions.length
    const score = Math.max(0, (correctSelected.length - incorrectSelected.length) / totalCorrect) * question.points
    
    return {
      isCorrect: correctSelected.length === totalCorrect && incorrectSelected.length === 0,
      score: Math.round(score * 100) / 100,
    }
  },

  gradeTrueFalse(question: any, userAnswer: any) {
    const correctOption = question.options.find((opt: any) => opt.isCorrect)
    const isCorrect = correctOption && userAnswer === correctOption.id
    return {
      isCorrect: !!isCorrect,
      score: isCorrect ? question.points : 0,
    }
  },

  gradeFillBlank(question: any, userAnswer: any) {
    // ç®€å•çš„å­—ç¬¦ä¸²åŒ¹é…ï¼Œå®é™…åº”ç”¨ä¸­å¯ä»¥æ›´å¤æ‚
    const correctAnswers = question.options
      .filter((opt: any) => opt.isCorrect)
      .map((opt: any) => opt.content.toLowerCase().trim())
    
    const userAnswerText = (userAnswer || '').toLowerCase().trim()
    const isCorrect = correctAnswers.some((answer: string) => answer === userAnswerText)
    
    return {
      isCorrect,
      score: isCorrect ? question.points : 0,
    }
  },

  async gradeEssay(question: any, userAnswer: any) {
    // ä½¿ç”¨AIè¯„åˆ†ç®€ç­”é¢˜
    try {
      const prompt = `
è¯·è¯„åˆ†ä»¥ä¸‹ç®€ç­”é¢˜ï¼š

é¢˜ç›®ï¼š${question.title}
é¢˜ç›®å†…å®¹ï¼š${JSON.stringify(question.content)}
æ ‡å‡†ç­”æ¡ˆ/è¯„åˆ†æ ‡å‡†ï¼š${question.explanation || 'æ— æ˜ç¡®æ ‡å‡†ç­”æ¡ˆ'}
å­¦ç”Ÿç­”æ¡ˆï¼š${userAnswer || 'æœªä½œç­”'}

è¯·æŒ‰ä»¥ä¸‹æ ¼å¼è¿”å›è¯„åˆ†ç»“æœï¼ˆJSONæ ¼å¼ï¼‰ï¼š
{
  "score": 0-${question.points},
  "feedback": "è¯„åˆ†ç†ç”±å’Œå»ºè®®",
  "isCorrect": true/false
}

è¯„åˆ†æ ‡å‡†ï¼š
- ç­”æ¡ˆæ­£ç¡®æ€§å’Œå®Œæ•´æ€§
- è¡¨è¾¾æ¸…æ™°åº¦
- é€»è¾‘æ€§
- å¦‚æœå­¦ç”Ÿæœªä½œç­”æˆ–ç­”æ¡ˆå®Œå…¨é”™è¯¯ï¼Œç»™0åˆ†
`

      const response = await aiService.generateCompletion(prompt, {
        maxTokens: 500,
        temperature: 0.3,
      })

      const result = JSON.parse(response)
      return {
        isCorrect: result.isCorrect || false,
        score: Math.min(Math.max(result.score || 0, 0), question.points),
        feedback: result.feedback,
      }
    } catch (error) {
      logger.error('AI grading error:', error)
      // é™çº§åˆ°äººå·¥è¯„åˆ†
      return {
        isCorrect: false,
        score: 0,
        needsManualGrading: true,
      }
    }
  },

  async updateExamStats(examId: string) {
    const records = await prisma.examRecord.findMany({
      where: {
        examId,
        status: { in: ['SUBMITTED', 'GRADED'] },
      },
      select: { score: true },
    })

    if (records.length === 0) return

    const scores = records.map(r => r.score || 0)
    const exam = await prisma.exam.findUnique({
      where: { id: examId },
      select: { passingScore: true },
    })

    const passedCount = exam?.passingScore 
      ? scores.filter(score => score >= exam.passingScore).length
      : 0

    await prisma.examStats.update({
      where: { examId },
      data: {
        totalAttempts: records.length,
        avgScore: scores.reduce((sum, score) => sum + score, 0) / scores.length,
        maxScore: Math.max(...scores),
        minScore: Math.min(...scores),
        passRate: records.length > 0 ? (passedCount / records.length) * 100 : 0,
      },
    })
  },
}
```

### å‰ç«¯ç»„ä»¶å®ç°

#### ã€frontend/src/pages/exams/ExamsPage.tsxã€‘- æ–°å¢æ–‡ä»¶
```tsx
import { useState, useEffect } from 'react'
import { useNavigate } from 'react-router-dom'
import { Helmet } from 'react-helmet-async'
import { examService } from '@/services/examService'
import { Button } from '@/components/ui/Button'
import { LoadingSpinner } from '@/components/ui/LoadingSpinner'
import { ExamCard } from '@/components/exams/ExamCard'
import { ExamFilters } from '@/components/exams/ExamFilters'
import { PlusIcon, AcademicCapIcon } from '@heroicons/react/24/outline'
import { useAuthStore } from '@/store/authStore'
import toast from 'react-hot-toast'

export default function ExamsPage() {
  const navigate = useNavigate()
  const { user } = useAuthStore()
  const [exams, setExams] = useState<any[]>([])
  const [isLoading, setIsLoading] = useState(true)
  const [filters, setFilters] = useState({
    type: '',
    status: '',
    search: '',
  })
  const [pagination, setPagination] = useState({
    page: 1,
    limit: 12,
    total: 0,
    totalPages: 0,
  })

  useEffect(() => {
    loadExams()
  }, [filters, pagination.page])

  const loadExams = async () => {
    try {
      setIsLoading(true)
      const result = await examService.getExams({
        ...filters,
        page: pagination.page,
        limit: pagination.limit,
      })
      setExams(result.exams)
      setPagination(result.pagination)
    } catch (err: any) {
      toast.error('åŠ è½½è€ƒè¯•åˆ—è¡¨å¤±è´¥')
    } finally {
      setIsLoading(false)
    }
  }

  const handleStartExam = async (examId: string) => {
    try {
      await examService.startExam(examId)
      navigate(`/exams/${examId}/take`)
    } catch (err: any) {
      toast.error(err.message || 'å¼€å§‹è€ƒè¯•å¤±è´¥')
    }
  }

  const canCreateExam = user?.role === 'TEACHER' || user?.role === 'ADMIN'

  return (
    <>
      <Helmet>
        <title>è€ƒè¯•ä¸­å¿ƒ - AIå­¦ä¹ ç®¡ç†ç³»ç»Ÿ</title>
      </Helmet>

      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div className="mb-8 flex justify-between items-center">
          <div>
            <h1 className="text-3xl font-bold text-gray-900 flex items-center gap-3">
              <AcademicCapIcon className="h-8 w-8 text-primary-600" />
              è€ƒè¯•ä¸­å¿ƒ
            </h1>
            <p className="mt-2 text-gray-600">
              å‚åŠ å„ç§è€ƒè¯•ï¼Œæ£€éªŒå­¦ä¹ æˆæœ
            </p>
          </div>
          {canCreateExam && (
            <Button
              onClick={() => navigate('/exams/create')}
              icon={PlusIcon}
            >
              åˆ›å»ºè€ƒè¯•
            </Button>
          )}
        </div>

        {/* Filters */}
        <div className="mb-6">
          <ExamFilters
            filters={filters}
            onFiltersChange={setFilters}
          />
        </div>

        {/* Exams Grid */}
        {isLoading ? (
          <LoadingSpinner className="py-12" />
        ) : exams.length === 0 ? (
          <div className="text-center py-12">
            <AcademicCapIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
            <p className="text-gray-500">æš‚æ— è€ƒè¯•</p>
            {canCreateExam && (
              <Button
                variant="outline"
                className="mt-4"
                onClick={() => navigate('/exams/create')}
              >
                åˆ›å»ºç¬¬ä¸€ä¸ªè€ƒè¯•
              </Button>
            )}
          </div>
        ) : (
          <>
            <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
              {exams.map(exam => (
                <ExamCard
                  key={exam.id}
                  exam={exam}
                  onStart={() => handleStartExam(exam.id)}
                  onClick={() => navigate(`/exams/${exam.id}`)}
                />
              ))}
            </div>

            {/* Pagination */}
            {pagination.totalPages > 1 && (
              <div className="mt-8 flex justify-center">
                <nav className="flex items-center gap-2">
                  <Button
                    variant="outline"
                    size="sm"
                    disabled={pagination.page === 1}
                    onClick={() => setPagination(prev => ({ ...prev, page: prev.page - 1 }))}
                  >
                    ä¸Šä¸€é¡µ
                  </Button>
                  <span className="px-3 py-1 text-sm text-gray-600">
                    ç¬¬ {pagination.page} é¡µï¼Œå…± {pagination.totalPages} é¡µ
                  </span>
                  <Button
                    variant="outline"
                    size="sm"
                    disabled={pagination.page === pagination.totalPages}
                    onClick={() => setPagination(prev => ({ ...prev, page: prev.page + 1 }))}
                  >
                    ä¸‹ä¸€é¡µ
                  </Button>
                </nav>
              </div>
            )}
          </>
        )}
      </div>
    </>
  )
}
```

#### ã€frontend/src/pages/exams/ExamTakePage.tsxã€‘- æ–°å¢æ–‡ä»¶
```tsx
import { useState, useEffect, useCallback } from 'react'
import { useParams, useNavigate } from 'react-router-dom'
import { Helmet } from 'react-helmet-async'
import { examService } from '@/services/examService'
import { LoadingSpinner } from '@/components/ui/LoadingSpinner'
import { Button } from '@/components/ui/Button'
import { Alert } from '@/components/ui/Alert'
import { QuestionRenderer } from '@/components/exams/QuestionRenderer'
import { ExamTimer } from '@/components/exams/ExamTimer'
import { ExamNavigation } from '@/components/exams/ExamNavigation'
import { SubmitExamModal } from '@/components/exams/SubmitExamModal'
import { ClockIcon, CheckCircleIcon } from '@heroicons/react/24/outline'
import toast from 'react-hot-toast'

export default function ExamTakePage() {
  const { examId } = useParams<{ examId: string }>()
  const navigate = useNavigate()
  
  const [exam, setExam] = useState<any>(null)
  const [examRecord, setExamRecord] = useState<any>(null)
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0)
  const [answers, setAnswers] = useState<Record<string, any>>({})
  const [isLoading, setIsLoading] = useState(true)
  const [isSaving, setIsSaving] = useState(false)
  const [showSubmitModal, setShowSubmitModal] = useState(false)
  const [timeRemaining, setTimeRemaining] = useState<number | null>(null)

  useEffect(() => {
    if (examId) {
      loadExam()
    }
  }, [examId])

  const loadExam = async () => {
    try {
      setIsLoading(true)
      const [examData, recordData] = await Promise.all([
        examService.getExamDetails(examId!),
        examService.getExamRecord(examId!),
      ])
      
      setExam(examData)
      setExamRecord(recordData)
      
      // åŠ è½½å·²æœ‰ç­”æ¡ˆ
      if (recordData?.answers) {
        const existingAnswers = recordData.answers.reduce((acc: any, answer: any) => {
          acc[answer.questionId] = answer.content
          return acc
        }, {})
        setAnswers(existingAnswers)
      }
      
      // è®¡ç®—å‰©ä½™æ—¶é—´
      if (examData.timeLimit && recordData) {
        const elapsedTime = Math.floor((new Date().getTime() - new Date(recordData.startedAt).getTime()) / 1000)
        const remainingTime = (examData.timeLimit * 60) - elapsedTime
        setTimeRemaining(Math.max(0, remainingTime))
      }
    } catch (err: any) {
      toast.error('åŠ è½½è€ƒè¯•å¤±è´¥')
      navigate('/exams')
    } finally {
      setIsLoading(false)
    }
  }

  const handleAnswerChange = useCallback(async (questionId: string, answer: any) => {
    setAnswers(prev => ({ ...prev, [questionId]: answer }))
    
    // è‡ªåŠ¨ä¿å­˜ç­”æ¡ˆ
    try {
      setIsSaving(true)
      await examService.submitAnswer(examId!, {
        questionId,
        content: answer,
      })
    } catch (err: any) {
      console.error('Failed to save answer:', err)
    } finally {
      setIsSaving(false)
    }
  }, [examId])

  const handleNavigateQuestion = (index: number) => {
    setCurrentQuestionIndex(index)
  }

  const handleNextQuestion = () => {
    if (currentQuestionIndex < exam.questions.length - 1) {
      setCurrentQuestionIndex(prev => prev + 1)
    }
  }

  const handlePrevQuestion = () => {
    if (currentQuestionIndex > 0) {
      setCurrentQuestionIndex(prev => prev - 1)
    }
  }

  const handleSubmitExam = async () => {
    try {
      const result = await examService.finishExam(examId!)
      toast.success('è€ƒè¯•æäº¤æˆåŠŸï¼')
      navigate(`/exams/${examId}/result`)
    } catch (err: any) {
      toast.error('æäº¤è€ƒè¯•å¤±è´¥')
    }
    setShowSubmitModal(false)
  }

  const handleTimeUp = () => {
    toast.warning('è€ƒè¯•æ—¶é—´å·²åˆ°ï¼Œè‡ªåŠ¨æäº¤ä¸­...')
    handleSubmitExam()
  }

  if (isLoading) {
    return <LoadingSpinner className="min-h-screen" />
  }

  if (!exam || !examRecord) {
    return (
      <div className="max-w-4xl mx-auto px-4 py-8">
        <Alert type="error">
          æ— æ³•åŠ è½½è€ƒè¯•ï¼Œè¯·ç¨åé‡è¯•
        </Alert>
      </div>
    )
  }

  const currentQuestion = exam.questions[currentQuestionIndex]
  const answeredCount = Object.keys(answers).length
  const progress = (answeredCount / exam.questions.length) * 100

  return (
    <>
      <Helmet>
        <title>{exam.title} - æ­£åœ¨è€ƒè¯•</title>
      </Helmet>

      <div className="min-h-screen bg-gray-50">
        {/* Header */}
        <div className="bg-white shadow-sm border-b">
          <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
            <div className="flex items-center justify-between">
              <div>
                <h1 className="text-xl font-semibold text-gray-900">{exam.title}</h1>
                <div className="mt-1 flex items-center gap-4 text-sm text-gray-600">
                  <span>é¢˜ç›® {currentQuestionIndex + 1} / {exam.questions.length}</span>
                  <span className="flex items-center gap-1">
                    <CheckCircleIcon className="h-4 w-4" />
                    å·²ç­” {answeredCount} é¢˜
                  </span>
                </div>
              </div>
              
              <div className="flex items-center gap-4">
                {isSaving && (
                  <span className="text-sm text-gray-500">ä¿å­˜ä¸­...</span>
                )}
                {timeRemaining !== null && (
                  <ExamTimer
                    timeRemaining={timeRemaining}
                    onTimeUp={handleTimeUp}
                  />
                )}
                <Button
                  onClick={() => setShowSubmitModal(true)}
                  variant="primary"
                >
                  æäº¤è€ƒè¯•
                </Button>
              </div>
            </div>
          </div>
        </div>

        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
          <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
            {/* Navigation Sidebar */}
            <div className="lg:col-span-1">
              <ExamNavigation
                questions={exam.questions}
                answers={answers}
                currentIndex={currentQuestionIndex}
                onNavigate={handleNavigateQuestion}
              />
            </div>

            {/* Question Content */}
            <div className="lg:col-span-3">
              <div className="bg-white rounded-lg shadow p-6">
                <QuestionRenderer
                  question={currentQuestion.question}
                  answer={answers[currentQuestion.question.id]}
                  onAnswerChange={(answer) => handleAnswerChange(currentQuestion.question.id, answer)}
                  questionNumber={currentQuestionIndex + 1}
                />

                {/* Navigation Buttons */}
                <div className="mt-8 flex justify-between">
                  <Button
                    variant="outline"
                    onClick={handlePrevQuestion}
                    disabled={currentQuestionIndex === 0}
                  >
                    ä¸Šä¸€é¢˜
                  </Button>
                  
                  <Button
                    onClick={handleNextQuestion}
                    disabled={currentQuestionIndex === exam.questions.length - 1}
                  >
                    ä¸‹ä¸€é¢˜
                  </Button>
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Submit Modal */}
        {showSubmitModal && (
          <SubmitExamModal
            exam={exam}
            answeredCount={answeredCount}
            totalQuestions={exam.questions.length}
            onConfirm={handleSubmitExam}
            onCancel={() => setShowSubmitModal(false)}
          />
        )}
      </div>
    </>
  )
}
```

#### ã€frontend/src/components/exams/QuestionRenderer.tsxã€‘- æ–°å¢æ–‡ä»¶
```tsx
import React from 'react'
import { SingleChoiceQuestion } from './questions/SingleChoiceQuestion'
import { MultipleChoiceQuestion } from './questions/MultipleChoiceQuestion'
import { TrueFalseQuestion } from './questions/TrueFalseQuestion'
import { FillBlankQuestion } from './questions/FillBlankQuestion'
import { EssayQuestion } from './questions/EssayQuestion'

interface QuestionRendererProps {
  question: {
    id: string
    title: string
    content: any
    type: string
    points: number
    timeLimit?: number
    options?: Array<{
      id: string
      content: string
      order: number
    }>
  }
  answer?: any
  onAnswerChange: (answer: any) => void
  questionNumber: number
  showCorrectAnswer?: boolean
  isReview?: boolean
}

export const QuestionRenderer: React.FC<QuestionRendererProps> = ({
  question,
  answer,
  onAnswerChange,
  questionNumber,
  showCorrectAnswer = false,
  isReview = false,
}) => {
  const renderQuestionByType = () => {
    const commonProps = {
      question,
      answer,
      onAnswerChange,
      showCorrectAnswer,
      disabled: isReview,
    }

    switch (question.type) {
      case 'SINGLE_CHOICE':
        return <SingleChoiceQuestion {...commonProps} />
      
      case 'MULTIPLE_CHOICE':
        return <MultipleChoiceQuestion {...commonProps} />
      
      case 'TRUE_FALSE':
        return <TrueFalseQuestion {...commonProps} />
      
      case 'FILL_BLANK':
        return <FillBlankQuestion {...commonProps} />
      
      case 'ESSAY':
        return <EssayQuestion {...commonProps} />
      
      default:
        return <div>ä¸æ”¯æŒçš„é¢˜ç›®ç±»å‹</div>
    }
  }

  return (
    <div className="space-y-6">
      {/* Question Header */}
      <div className="flex items-start justify-between">
        <div className="flex-1">
          <div className="flex items-center gap-3 mb-3">
            <span className="inline-flex items-center justify-center w-8 h-8 rounded-full bg-primary-100 text-primary-700 text-sm font-medium">
              {questionNumber}
            </span>
            <div className="flex items-center gap-2 text-sm text-gray-500">
              <span>{question.points} åˆ†</span>
              {question.timeLimit && (
                <span>â€¢ å»ºè®®ç”¨æ—¶ {question.timeLimit} ç§’</span>
              )}
            </div>
          </div>
          
          <h3 className="text-lg font-medium text-gray-900 mb-4">
            {question.title}
          </h3>
          
          {/* Question Content */}
          {question.content && (
            <div className="prose prose-sm max-w-none mb-6">
              {typeof question.content === 'string' ? (
                <p>{question.content}</p>
              ) : (
                <div dangerouslySetInnerHTML={{ __html: question.content.html || '' }} />
              )}
            </div>
          )}
        </div>
      </div>

      {/* Question Input */}
      {renderQuestionByType()}
    </div>
  )
}
```

#### ã€frontend/src/components/exams/questions/SingleChoiceQuestion.tsxã€‘- æ–°å¢æ–‡ä»¶
```tsx
import React from 'react'
import { cn } from '@/utils/cn'

interface SingleChoiceQuestionProps {
  question: {
    id: string
    options?: Array<{
      id: string
      content: string
      isCorrect?: boolean
    }>
  }
  answer?: string
  onAnswerChange: (answer: string) => void
  showCorrectAnswer?: boolean
  disabled?: boolean
}

export const SingleChoiceQuestion: React.FC<SingleChoiceQuestionProps> = ({
  question,
  answer,
  onAnswerChange,
  showCorrectAnswer = false,
  disabled = false,
}) => {
  const options = question.options || []

  const getOptionClassName = (option: any) => {
    const base = 'relative border rounded-lg p-4 cursor-pointer transition-all hover:bg-gray-50'
    
    if (disabled) {
      return cn(base, 'cursor-not-allowed opacity-75')
    }
    
    if (showCorrectAnswer) {
      if (option.isCorrect) {
        return cn(base, 'border-green-500 bg-green-50')
      }
      if (answer === option.id && !option.isCorrect) {
        return cn(base, 'border-red-500 bg-red-50')
      }
    }
    
    if (answer === option.id) {
      return cn(base, 'border-primary-500 bg-primary-50')
    }
    
    return cn(base, 'border-gray-300')
  }

  return (
    <div className="space-y-3">
      {options.map((option, index) => (
        <label
          key={option.id}
          className={getOptionClassName(option)}
        >
          <div className="flex items-start gap-3">
            <input
              type="radio"
              name={`question-${question.id}`}
              value={option.id}
              checked={answer === option.id}
              onChange={(e) => !disabled && onAnswerChange(e.target.value)}
              disabled={disabled}
              className="mt-0.5 h-4 w-4 text-primary-600 border-gray-300 focus:ring-primary-500"
            />
            <div className="flex-1">
              <span className="inline-flex items-center justify-center w-6 h-6 rounded-full bg-gray-100 text-gray-600 text-sm font-medium mr-3">
                {String.fromCharCode(65 + index)}
              </span>
              <span className="text-gray-900">{option.content}</span>
            </div>
            
            {showCorrectAnswer && option.isCorrect && (
              <div className="text-green-600 text-sm font-medium">
                âœ“ æ­£ç¡®ç­”æ¡ˆ
              </div>
            )}
          </div>
        </label>
      ))}
    </div>
  )
}
```

#### ã€frontend/src/components/exams/questions/MultipleChoiceQuestion.tsxã€‘- æ–°å¢æ–‡ä»¶
```tsx
import React from 'react'
import { cn } from '@/utils/cn'

interface MultipleChoiceQuestionProps {
  question: {
    id: string
    options?: Array<{
      id: string
      content: string
      isCorrect?: boolean
    }>
  }
  answer?: string[]
  onAnswerChange: (answer: string[]) => void
  showCorrectAnswer?: boolean
  disabled?: boolean
}

export const MultipleChoiceQuestion: React.FC<MultipleChoiceQuestionProps> = ({
  question,
  answer = [],
  onAnswerChange,
  showCorrectAnswer = false,
  disabled = false,
}) => {
  const

  # DAY6 å®Œæ•´å¼€å‘æ—¥å¿—ä¸æºç  - æµ‹è¯•ä¸è€ƒè¯•ç³»ç»Ÿ

## ğŸ“… DAY6 å¼€å‘æ—¥å¿— - 2025-05-28

### é¡¹ç›®æ¦‚è¿°
**å½“å‰è¿›åº¦**: 6/8é˜¶æ®µ (75%)  
**å¼€å‘é‡ç‚¹**: ç¬¬å…­é˜¶æ®µ - æµ‹è¯•ä¸è€ƒè¯•ç³»ç»Ÿå®Œæ•´å®ç°  
**æŠ€æœ¯æ ˆ**: React 18 + TypeScript + Fastify + PostgreSQL + Redis + AIè¯„åˆ†

---

## ğŸš€ å¼€å‘è¿›å±•æ€»ç»“

### ä¸Šåˆä»»åŠ¡å®Œæˆæƒ…å†µ (09:00-12:00) âœ…
- **æ•°æ®åº“æ¨¡å‹è®¾è®¡**: å®Œæˆ6ä¸ªæ ¸å¿ƒè¡¨ç»“æ„è®¾è®¡
- **åç«¯APIå¼€å‘**: å®ç°é¢˜åº“ç®¡ç†å’Œè€ƒè¯•å¼•æ“API
- **ä¸šåŠ¡é€»è¾‘å±‚**: å®ŒæˆquestionServiceå’ŒexamServiceæ ¸å¿ƒåŠŸèƒ½

### ä¸‹åˆä»»åŠ¡å®Œæˆæƒ…å†µ (14:00-18:00) âœ…  
- **å‰ç«¯ç»„ä»¶å¼€å‘**: å®Œæˆç­”é¢˜ç•Œé¢å’Œé¢˜å‹ç»„ä»¶
- **æ™ºèƒ½è¯„åˆ†ç³»ç»Ÿ**: é›†æˆAIè¯„åˆ†å’Œè‡ªåŠ¨è¯„åˆ†ç®—æ³•
- **è€ƒè¯•ç®¡ç†ç•Œé¢**: å®ç°æ•™å¸ˆç«¯å’Œå­¦ç”Ÿç«¯åŠŸèƒ½

### æ™šä¸Šä»»åŠ¡å®Œæˆæƒ…å†µ (19:00-21:00) âœ…
- **ç³»ç»Ÿé›†æˆæµ‹è¯•**: å®Œæ•´æµç¨‹éªŒè¯
- **æ€§èƒ½ä¼˜åŒ–**: ç¼“å­˜å’Œå¹¶å‘ä¼˜åŒ–
- **å®‰å…¨æœºåˆ¶**: é˜²ä½œå¼ŠåŠŸèƒ½å®ç°

---

## ğŸ’» æ ¸å¿ƒæŠ€æœ¯å®ç°

### 1. æ•°æ®åº“æ¶æ„å‡çº§
è®¾è®¡äº†è€ƒè¯•ç³»ç»Ÿçš„å®Œæ•´æ•°æ®æ¨¡å‹ï¼Œæ”¯æŒå¤æ‚çš„è€ƒè¯•é€»è¾‘å’Œå¤šç§é¢˜å‹ã€‚

### 2. æ™ºèƒ½è¯„åˆ†å¼•æ“
- **å®¢è§‚é¢˜è‡ªåŠ¨è¯„åˆ†**: ç²¾ç¡®åŒ¹é…ç®—æ³•
- **ä¸»è§‚é¢˜AIè¯„åˆ†**: é›†æˆOpenAIè¿›è¡Œæ™ºèƒ½è¯„åˆ†
- **éƒ¨åˆ†åˆ†æ•°æ”¯æŒ**: å¤šé€‰é¢˜æ”¯æŒæŒ‰æ¯”ä¾‹ç»™åˆ†

### 3. è€ƒè¯•å®‰å…¨æœºåˆ¶
- **é˜²åˆ‡å±æ£€æµ‹**: å‰ç«¯ç›‘æ§é¡µé¢ç„¦ç‚¹
- **æ—¶é—´æ§åˆ¶**: ç²¾ç¡®çš„è€ƒè¯•æ—¶é—´ç®¡ç†
- **æ•°æ®åŠ å¯†**: ç­”æ¡ˆä¼ è¾“åŠ å¯†ä¿æŠ¤

---

## ğŸ“‹ å®Œæ•´æºç å®ç°

### åç«¯æºç ç»§ç»­

#### ã€backend/src/services/examService.tsã€‘- è¡¥å……å®Œæ•´
```typescript
// ç»­å†™MultipleChoiceQuestionç»„ä»¶
options = question.options || []

  const handleOptionChange = (optionId: string, checked: boolean) => {
    if (disabled) return
    
    let newAnswer = [...answer]
    if (checked) {
      if (!newAnswer.includes(optionId)) {
        newAnswer.push(optionId)
      }
    } else {
      newAnswer = newAnswer.filter(id => id !== optionId)
    }
    onAnswerChange(newAnswer)
  }

  const getOptionClassName = (option: any) => {
    const base = 'relative border rounded-lg p-4 cursor-pointer transition-all hover:bg-gray-50'
    
    if (disabled) {
      return cn(base, 'cursor-not-allowed opacity-75')
    }
    
    if (showCorrectAnswer) {
      if (option.isCorrect) {
        return cn(base, 'border-green-500 bg-green-50')
      }
      if (answer.includes(option.id) && !option.isCorrect) {
        return cn(base, 'border-red-500 bg-red-50')
      }
    }
    
    if (answer.includes(option.id)) {
      return cn(base, 'border-primary-500 bg-primary-50')
    }
    
    return cn(base, 'border-gray-300')
  }

  return (
    <div className="space-y-3">
      <div className="text-sm text-gray-600 mb-3">
        è¯·é€‰æ‹©æ‰€æœ‰æ­£ç¡®ç­”æ¡ˆï¼ˆå¯å¤šé€‰ï¼‰
      </div>
      {options.map((option, index) => (
        <label
          key={option.id}
          className={getOptionClassName(option)}
        >
          <div className="flex items-start gap-3">
            <input
              type="checkbox"
              checked={answer.includes(option.id)}
              onChange={(e) => handleOptionChange(option.id, e.target.checked)}
              disabled={disabled}
              className="mt-0.5 h-4 w-4 text-primary-600 border-gray-300 rounded focus:ring-primary-500"
            />
            <div className="flex-1">
              <span className="inline-flex items-center justify-center w-6 h-6 rounded-full bg-gray-100 text-gray-600 text-sm font-medium mr-3">
                {String.fromCharCode(65 + index)}
              </span>
              <span className="text-gray-900">{option.content}</span>
            </div>
            
            {showCorrectAnswer && option.isCorrect && (
              <div className="text-green-600 text-sm font-medium">
                âœ“ æ­£ç¡®ç­”æ¡ˆ
              </div>
            )}
          </div>
        </label>
      ))}
    </div>
  )
}
```

#### ã€frontend/src/components/exams/questions/TrueFalseQuestion.tsxã€‘- æ–°å¢æ–‡ä»¶
```tsx
import React from 'react'
import { cn } from '@/utils/cn'

interface TrueFalseQuestionProps {
  question: {
    id: string
    options?: Array<{
      id: string
      content: string
      isCorrect?: boolean
    }>
  }
  answer?: string
  onAnswerChange: (answer: string) => void
  showCorrectAnswer?: boolean
  disabled?: boolean
}

export const TrueFalseQuestion: React.FC<TrueFalseQuestionProps> = ({
  question,
  answer,
  onAnswerChange,
  showCorrectAnswer = false,
  disabled = false,
}) => {
  const trueOption = { id: 'true', content: 'æ­£ç¡®', isCorrect: question.options?.[0]?.isCorrect }
  const falseOption = { id: 'false', content: 'é”™è¯¯', isCorrect: question.options?.[1]?.isCorrect }
  
  const options = [trueOption, falseOption]

  const getOptionClassName = (option: any) => {
    const base = 'relative border rounded-lg p-4 cursor-pointer transition-all hover:bg-gray-50 flex items-center justify-center min-h-[60px]'
    
    if (disabled) {
      return cn(base, 'cursor-not-allowed opacity-75')
    }
    
    if (showCorrectAnswer) {
      if (option.isCorrect) {
        return cn(base, 'border-green-500 bg-green-50')
      }
      if (answer === option.id && !option.isCorrect) {
        return cn(base, 'border-red-500 bg-red-50')
      }
    }
    
    if (answer === option.id) {
      return cn(base, 'border-primary-500 bg-primary-50')
    }
    
    return cn(base, 'border-gray-300')
  }

  return (
    <div className="space-y-4">
      <div className="text-sm text-gray-600 mb-4">
        è¯·åˆ¤æ–­ä»¥ä¸‹è¯´æ³•æ˜¯å¦æ­£ç¡®
      </div>
      <div className="grid grid-cols-2 gap-4">
        {options.map((option) => (
          <label
            key={option.id}
            className={getOptionClassName(option)}
          >
            <div className="text-center">
              <input
                type="radio"
                name={`question-${question.id}`}
                value={option.id}
                checked={answer === option.id}
                onChange={(e) => !disabled && onAnswerChange(e.target.value)}
                disabled={disabled}
                className="sr-only"
              />
              <div className="text-lg font-medium text-gray-900">
                {option.content}
              </div>
              {showCorrectAnswer && option.isCorrect && (
                <div className="text-green-600 text-sm font-medium mt-1">
                  âœ“ æ­£ç¡®ç­”æ¡ˆ
                </div>
              )}
            </div>
          </label>
        ))}
      </div>
    </div>
  )
}
```

#### ã€frontend/src/components/exams/questions/FillBlankQuestion.tsxã€‘- æ–°å¢æ–‡ä»¶
```tsx
import React from 'react'
import { cn } from '@/utils/cn'

interface FillBlankQuestionProps {
  question: {
    id: string
    content: any
    options?: Array<{
      id: string
      content: string
      isCorrect?: boolean
    }>
  }
  answer?: string
  onAnswerChange: (answer: string) => void
  showCorrectAnswer?: boolean
  disabled?: boolean
}

export const FillBlankQuestion: React.FC<FillBlankQuestionProps> = ({
  question,
  answer = '',
  onAnswerChange,
  showCorrectAnswer = false,
  disabled = false,
}) => {
  const correctAnswers = question.options?.filter(opt => opt.isCorrect).map(opt => opt.content) || []
  const isCorrect = correctAnswers.some(correct => 
    correct.toLowerCase().trim() === (answer || '').toLowerCase().trim()
  )

  return (
    <div className="space-y-4">
      <div className="text-sm text-gray-600 mb-4">
        è¯·åœ¨ä¸‹æ–¹è¾“å…¥æ¡†ä¸­å¡«å†™ç­”æ¡ˆ
      </div>
      
      <div className="relative">
        <input
          type="text"
          value={answer}
          onChange={(e) => !disabled && onAnswerChange(e.target.value)}
          disabled={disabled}
          placeholder="è¯·è¾“å…¥ç­”æ¡ˆ..."
          className={cn(
            'w-full px-4 py-3 border rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-primary-500',
            disabled && 'bg-gray-50 cursor-not-allowed',
            showCorrectAnswer && isCorrect && 'border-green-500 bg-green-50',
            showCorrectAnswer && !isCorrect && answer && 'border-red-500 bg-red-50'
          )}
        />
        
        {showCorrectAnswer && (
          <div className="mt-3 p-3 bg-gray-50 rounded-lg">
            <div className="text-sm font-medium text-gray-700 mb-1">å‚è€ƒç­”æ¡ˆï¼š</div>
            <div className="text-sm text-gray-600">
              {correctAnswers.join(' æˆ– ')}
            </div>
          </div>
        )}
      </div>
      
      {answer && (
        <div className="text-sm text-gray-500">
          å·²è¾“å…¥ {answer.length} ä¸ªå­—ç¬¦
        </div>
      )}
    </div>
  )
}
```

#### ã€frontend/src/components/exams/questions/EssayQuestion.tsxã€‘- æ–°å¢æ–‡ä»¶
```tsx
import React from 'react'
import { cn } from '@/utils/cn'

interface EssayQuestionProps {
  question: {
    id: string
    content: any
    explanation?: string
  }
  answer?: string
  onAnswerChange: (answer: string) => void
  showCorrectAnswer?: boolean
  disabled?: boolean
}

export const EssayQuestion: React.FC<EssayQuestionProps> = ({
  question,
  answer = '',
  onAnswerChange,
  showCorrectAnswer = false,
  disabled = false,
}) => {
  const wordCount = answer.length
  const minWords = 50 // æœ€å°‘å­—æ•°è¦æ±‚

  return (
    <div className="space-y-4">
      <div className="text-sm text-gray-600 mb-4">
        è¯·è¯¦ç»†é˜è¿°æ‚¨çš„è§‚ç‚¹å’Œç†ç”±ï¼ˆå»ºè®®ä¸å°‘äº{minWords}å­—ï¼‰
      </div>
      
      <div className="relative">
        <textarea
          value={answer}
          onChange={(e) => !disabled && onAnswerChange(e.target.value)}
          disabled={disabled}
          placeholder="è¯·åœ¨æ­¤è¾“å…¥æ‚¨çš„ç­”æ¡ˆ..."
          rows={8}
          className={cn(
            'w-full px-4 py-3 border rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-primary-500 resize-vertical',
            disabled && 'bg-gray-50 cursor-not-allowed'
          )}
        />
        
        <div className="absolute bottom-3 right-3 text-xs text-gray-400">
          {wordCount} å­—
        </div>
      </div>
      
      <div className="flex justify-between items-center text-sm">
        <div className={cn(
          'text-gray-500',
          wordCount < minWords && 'text-orange-600',
          wordCount >= minWords && 'text-green-600'
        )}>
          {wordCount < minWords ? `è¿˜éœ€ ${minWords - wordCount} å­—è¾¾åˆ°å»ºè®®å­—æ•°` : 'å·²è¾¾åˆ°å»ºè®®å­—æ•°'}
        </div>
        <div className="text-gray-400">
          æ­¤é¢˜å°†ç”±AIæ™ºèƒ½è¯„åˆ†
        </div>
      </div>
      
      {showCorrectAnswer && question.explanation && (
        <div className="mt-4 p-4 bg-blue-50 rounded-lg">
          <div className="text-sm font-medium text-blue-700 mb-2">å‚è€ƒç­”æ¡ˆè¦ç‚¹ï¼š</div>
          <div className="text-sm text-blue-600 whitespace-pre-wrap">
            {question.explanation}
          </div>
        </div>
      )}
    </div>
  )
}
```

#### ã€frontend/src/components/exams/ExamTimer.tsxã€‘- æ–°å¢æ–‡ä»¶
```tsx
import React, { useState, useEffect } from 'react'
import { ClockIcon } from '@heroicons/react/24/outline'
import { cn } from '@/utils/cn'

interface ExamTimerProps {
  timeRemaining: number // å‰©ä½™ç§’æ•°
  onTimeUp: () => void
  warningThreshold?: number // è­¦å‘Šé˜ˆå€¼ï¼ˆç§’ï¼‰
}

export const ExamTimer: React.FC<ExamTimerProps> = ({
  timeRemaining: initialTime,
  onTimeUp,
  warningThreshold = 300, // 5åˆ†é’Ÿè­¦å‘Š
}) => {
  const [timeLeft, setTimeLeft] = useState(initialTime)

  useEffect(() => {
    setTimeLeft(initialTime)
  }, [initialTime])

  useEffect(() => {
    if (timeLeft <= 0) {
      onTimeUp()
      return
    }

    const timer = setInterval(() => {
      setTimeLeft(prev => {
        const newTime = prev - 1
        if (newTime <= 0) {
          onTimeUp()
          return 0
        }
        return newTime
      })
    }, 1000)

    return () => clearInterval(timer)
  }, [timeLeft, onTimeUp])

  const formatTime = (seconds: number) => {
    const hours = Math.floor(seconds / 3600)
    const minutes = Math.floor((seconds % 3600) / 60)
    const secs = seconds % 60

    if (hours > 0) {
      return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
    }
    return `${minutes}:${secs.toString().padStart(2, '0')}`
  }

  const isWarning = timeLeft <= warningThreshold && timeLeft > 60
  const isCritical = timeLeft <= 60

  return (
    <div className={cn(
      'flex items-center gap-2 px-3 py-2 rounded-lg font-mono text-sm',
      isCritical && 'bg-red-100 text-red-700 animate-pulse',
      isWarning && !isCritical && 'bg-orange-100 text-orange-700',
      !isWarning && !isCritical && 'bg-gray-100 text-gray-700'
    )}>
      <ClockIcon className="h-4 w-4" />
      <span className="font-medium">
        å‰©ä½™æ—¶é—´: {formatTime(timeLeft)}
      </span>
      {isCritical && (
        <span className="text-xs">å³å°†ç»“æŸ!</span>
      )}
    </div>
  )
}
```

#### ã€frontend/src/components/exams/ExamNavigation.tsxã€‘- æ–°å¢æ–‡ä»¶
```tsx
import React from 'react'
import { CheckCircleIcon, ClockIcon } from '@heroicons/react/24/outline'
import { cn } from '@/utils/cn'

interface ExamNavigationProps {
  questions: Array<{
    id: string
    question: {
      id: string
      title: string
      type: string
    }
  }>
  answers: Record<string, any>
  currentIndex: number
  onNavigate: (index: number) => void
}

export const ExamNavigation: React.FC<ExamNavigationProps> = ({
  questions,
  answers,
  currentIndex,
  onNavigate,
}) => {
  const getQuestionStatus = (questionId: string) => {
    const answer = answers[questionId]
    if (answer === undefined || answer === '' || (Array.isArray(answer) && answer.length === 0)) {
      return 'unanswered'
    }
    return 'answered'
  }

  const getQuestionClassName = (index: number, questionId: string) => {
    const status = getQuestionStatus(questionId)
    const isCurrent = index === currentIndex
    
    const base = 'w-10 h-10 rounded-lg border-2 flex items-center justify-center text-sm font-medium cursor-pointer transition-all hover:scale-105'
    
    if (isCurrent) {
      return cn(base, 'border-primary-500 bg-primary-100 text-primary-700')
    }
    
    if (status === 'answered') {
      return cn(base, 'border-green-500 bg-green-100 text-green-700')
    }
    
    return cn(base, 'border-gray-300 bg-white text-gray-600 hover:border-gray-400')
  }

  const answeredCount = Object.keys(answers).length
  const totalQuestions = questions.length

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <div className="mb-6">
        <h3 className="text-lg font-semibold text-gray-900 mb-2">ç­”é¢˜è¿›åº¦</h3>
        <div className="flex items-center gap-2 text-sm text-gray-600">
          <CheckCircleIcon className="h-4 w-4" />
          <span>å·²ç­” {answeredCount} / {totalQuestions} é¢˜</span>
        </div>
        <div className="mt-2 bg-gray-200 rounded-full h-2">
          <div 
            className="bg-primary-500 rounded-full h-2 transition-all duration-300"
            style={{ width: `${(answeredCount / totalQuestions) * 100}%` }}
          />
        </div>
      </div>

      <div className="mb-4">
        <h4 className="text-sm font-medium text-gray-700 mb-3">é¢˜ç›®å¯¼èˆª</h4>
        <div className="grid grid-cols-5 gap-2">
          {questions.map((questionItem, index) => (
            <button
              key={questionItem.id}
              onClick={() => onNavigate(index)}
              className={getQuestionClassName(index, questionItem.question.id)}
              title={`ç¬¬${index + 1}é¢˜: ${questionItem.question.title}`}
            >
              {index + 1}
            </button>
          ))}
        </div>
      </div>

      <div className="border-t pt-4">
        <div className="space-y-2 text-xs">
          <div className="flex items-center gap-2">
            <div className="w-4 h-4 rounded border-2 border-primary-500 bg-primary-100"></div>
            <span className="text-gray-600">å½“å‰é¢˜ç›®</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-4 h-4 rounded border-2 border-green-500 bg-green-100"></div>
            <span className="text-gray-600">å·²ç­”é¢˜ç›®</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-4 h-4 rounded border-2 border-gray-300 bg-white"></div>
            <span className="text-gray-600">æœªç­”é¢˜ç›®</span>
          </div>
        </div>
      </div>
    </div>
  )
}
```

#### ã€frontend/src/components/exams/SubmitExamModal.tsxã€‘- æ–°å¢æ–‡ä»¶
```tsx
import React from 'react'
import { Dialog, Transition } from '@headlessui/react'
import { Fragment } from 'react'
import { ExclamationTriangleIcon, CheckCircleIcon } from '@heroicons/react/24/outline'
import { Button } from '@/components/ui/Button'

interface SubmitExamModalProps {
  exam: {
    title: string
    timeLimit?: number
  }
  answeredCount: number
  totalQuestions: number
  onConfirm: () => void
  onCancel: () => void
}

export const SubmitExamModal: React.FC<SubmitExamModalProps> = ({
  exam,
  answeredCount,
  totalQuestions,
  onConfirm,
  onCancel,
}) => {
  const unansweredCount = totalQuestions - answeredCount
  const completionRate = (answeredCount / totalQuestions) * 100

  return (
    <Transition appear show={true} as={Fragment}>
      <Dialog as="div" className="relative z-50" onClose={onCancel}>
        <Transition.Child
          as={Fragment}
          enter="ease-out duration-300"
          enterFrom="opacity-0"
          enterTo="opacity-100"
          leave="ease-in duration-200"
          leaveFrom="opacity-100"
          leaveTo="opacity-0"
        >
          <div className="fixed inset-0 bg-black bg-opacity-25" />
        </Transition.Child>

        <div className="fixed inset-0 overflow-y-auto">
          <div className="flex min-h-full items-center justify-center p-4 text-center">
            <Transition.Child
              as={Fragment}
              enter="ease-out duration-300"
              enterFrom="opacity-0 scale-95"
              enterTo="opacity-100 scale-100"
              leave="ease-in duration-200"
              leaveFrom="opacity-100 scale-100"
              leaveTo="opacity-0 scale-95"
            >
              <Dialog.Panel className="w-full max-w-md transform overflow-hidden rounded-2xl bg-white p-6 text-left align-middle shadow-xl transition-all">
                <div className="flex items-center gap-3 mb-4">
                  {unansweredCount > 0 ? (
                    <ExclamationTriangleIcon className="h-8 w-8 text-orange-500" />
                  ) : (
                    <CheckCircleIcon className="h-8 w-8 text-green-500" />
                  )}
                  <Dialog.Title
                    as="h3"
                    className="text-lg font-medium leading-6 text-gray-900"
                  >
                    ç¡®è®¤æäº¤è€ƒè¯•
                  </Dialog.Title>
                </div>

                <div className="space-y-4">
                  <div className="bg-gray-50 rounded-lg p-4">
                    <h4 className="font-medium text-gray-900 mb-2">{exam.title}</h4>
                    <div className="space-y-2 text-sm text-gray-600">
                      <div className="flex justify-between">
                        <span>ç­”é¢˜è¿›åº¦</span>
                        <span className="font-medium">{answeredCount} / {totalQuestions}</span>
                      </div>
                      <div className="flex justify-between">
                        <span>å®Œæˆç‡</span>
                        <span className="font-medium">{Math.round(completionRate)}%</span>
                      </div>
                      {unansweredCount > 0 && (
                        <div className="flex justify-between text-orange-600">
                          <span>æœªç­”é¢˜ç›®</span>
                          <span className="font-medium">{unansweredCount} é¢˜</span>
                        </div>
                      )}
                    </div>
                  </div>

                  {unansweredCount > 0 && (
                    <div className="bg-orange-50 border border-orange-200 rounded-lg p-3">
                      <div className="flex items-start gap-2">
                        <ExclamationTriangleIcon className="h-5 w-5 text-orange-500 mt-0.5" />
                        <div className="text-sm">
                          <p className="font-medium text-orange-800">æ³¨æ„</p>
                          <p className="text-orange-700">
                            æ‚¨è¿˜æœ‰ {unansweredCount} é“é¢˜ç›®æœªç­”ï¼Œæœªç­”é¢˜ç›®å°†ä¸ä¼šå¾—åˆ†ã€‚
                          </p>
                        </div>
                      </div>
                    </div>
                  )}

                  <div className="bg-blue-50 border border-blue-200 rounded-lg p-3">
                    <div className="text-sm text-blue-800">
                      <p className="font-medium mb-1">æäº¤åé¡»çŸ¥ï¼š</p>
                      <ul className="list-disc list-inside space-y-1 text-blue-700">
                        <li>è€ƒè¯•å°†ç«‹å³ç»“æŸï¼Œæ— æ³•å†æ¬¡ä¿®æ”¹ç­”æ¡ˆ</li>
                        <li>ç³»ç»Ÿå°†è‡ªåŠ¨è¯„åˆ†å¹¶ç”Ÿæˆæˆç»©æŠ¥å‘Š</li>
                        <li>ç®€ç­”é¢˜å°†ç”±AIæ™ºèƒ½è¯„åˆ†</li>
                      </ul>
                    </div>
                  </div>
                </div>

                <div className="mt-6 flex gap-3 justify-end">
                  <Button
                    variant="outline"
                    onClick={onCancel}
                  >
                    ç»§ç»­ç­”é¢˜
                  </Button>
                  <Button
                    variant="primary"
                    onClick={onConfirm}
                  >
                    ç¡®è®¤æäº¤
                  </Button>
                </div>
              </Dialog.Panel>
            </Transition.Child>
          </div>
        </div>
      </Dialog>
    </Transition>
  )
}
```

#### ã€frontend/src/components/exams/ExamCard.tsxã€‘- æ–°å¢æ–‡ä»¶
```tsx
import React from 'react'
import { ClockIcon, DocumentTextIcon, UsersIcon, CheckCircleIcon } from '@heroicons/react/24/outline'
import { formatDistanceToNow } from 'date-fns'
import { zhCN } from 'date-fns/locale'
import { Button } from '@/components/ui/Button'
import { cn } from '@/utils/cn'

interface ExamCardProps {
  exam: {
    id: string
    title: string
    description?: string
    type: string
    status: string
    timeLimit?: number
    totalPoints: number
    maxAttempts: number
    startTime?: string
    endTime?: string
    createdAt: string
    createdBy: {
      name: string
    }
    _count: {
      questions: number
      records: number
    }
    records?: Array<{
      id: string
      status: string
      score?: number
      submittedAt?: string
    }>
  }
  onStart?: () => void
  onClick: () => void
}

const examTypeLabels = {
  CHAPTER_TEST: 'ç« èŠ‚æµ‹è¯•',
  MOCK_EXAM: 'æ¨¡æ‹Ÿè€ƒè¯•',
  REAL_EXAM: 'çœŸé¢˜è€ƒè¯•',
  PRACTICE: 'ç»ƒä¹ æ¨¡å¼',
}

const examStatusLabels = {
  DRAFT: 'è‰ç¨¿',
  PUBLISHED: 'å·²å‘å¸ƒ',
  ACTIVE: 'è¿›è¡Œä¸­',
  ENDED: 'å·²ç»“æŸ',
  CANCELLED: 'å·²å–æ¶ˆ',
}

export const ExamCard: React.FC<ExamCardProps> = ({
  exam,
  onStart,
  onClick,
}) => {
  const userRecord = exam.records?.[0]
  const canStart = exam.status === 'PUBLISHED' && (!userRecord || userRecord.status !== 'SUBMITTED')
  const hasAttempted = userRecord && userRecord.status === 'SUBMITTED'
  
  // æ£€æŸ¥æ—¶é—´é™åˆ¶
  const now = new Date()
  const isTimeValid = (!exam.startTime || now >= new Date(exam.startTime)) &&
                     (!exam.endTime || now <= new Date(exam.endTime))

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'PUBLISHED':
        return 'text-green-600 bg-green-100'
      case 'ACTIVE':
        return 'text-blue-600 bg-blue-100'
      case 'ENDED':
        return 'text-gray-600 bg-gray-100'
      case 'DRAFT':
        return 'text-yellow-600 bg-yellow-100'
      default:
        return 'text-gray-600 bg-gray-100'
    }
  }

  return (
    <div
      className="bg-white rounded-lg shadow hover:shadow-lg transition-shadow cursor-pointer overflow-hidden"
      onClick={onClick}
    >
      <div className="p-6">
        {/* Header */}
        <div className="flex items-start justify-between mb-4">
          <div className="flex-1">
            <h3 className="text-lg font-semibold text-gray-900 mb-1">{exam.title}</h3>
            <div className="flex items-center gap-2">
              <span className="text-sm text-gray-500">
                {examTypeLabels[exam.type as keyof typeof examTypeLabels] || exam.type}
              </span>
              <span className={cn(
                'px-2 py-1 rounded-full text-xs font-medium',
                getStatusColor(exam.status)
              )}>
                {examStatusLabels[exam.status as keyof typeof examStatusLabels] || exam.status}
              </span>
            </div>
          </div>
        </div>

        {/* Description */}
        {exam.description && (
          <p className="text-sm text-gray-600 mb-4 line-clamp-2">{exam.description}</p>
        )}

        {/* Stats */}
        <div className="grid grid-cols-2 gap-4 mb-4 text-sm">
          <div className="flex items-center gap-2 text-gray-600">
            <DocumentTextIcon className="h-4 w-4" />
            <span>{exam._count.questions} é¢˜</span>
          </div>
          <div className="flex items-center gap-2 text-gray-600">
            <span className="text-orange-500">â˜…</span>
            <span>{exam.totalPoints} åˆ†</span>
          </div>
          {exam.timeLimit && (
            <div className="flex items-center gap-2 text-gray-600">
              <ClockIcon className="h-4 w-4" />
              <span>{exam.timeLimit} åˆ†é’Ÿ</span>
            </div>
          )}
          <div className="flex items-center gap-2 text-gray-600">
            <UsersIcon className="h-4 w-4" />
            <span>{exam._count.records} äººå‚åŠ </span>
          </div>
        </div>

        {/* User Status */}
        {hasAttempted && (
          <div className="mb-4 p-3 bg-green-50 rounded-lg">
            <div className="flex items-center gap-2">
              <CheckCircleIcon className="h-4 w-4 text-green-600" />
              <span className="text-sm font-medium text-green-800">å·²å®Œæˆ</span>
            </div>
            <div className="text-sm text-green-700 mt-1">
              å¾—åˆ†ï¼š{userRecord.score || 0} / {exam.totalPoints}
              {userRecord.submittedAt && (
                <span className="ml-2">
                  â€¢ {formatDistanceToNow(new Date(userRecord.submittedAt), {
                    addSuffix: true,
                    locale: zhCN,
                  })}
                </span>
              )}
            </div>
          </div>
        )}

        {/* Time constraints */}
        {(exam.startTime || exam.endTime) && (
          <div className="mb-4 text-xs text-gray-500">
            {exam.startTime && (
              <div>å¼€å§‹æ—¶é—´ï¼š{new Date(exam.startTime).toLocaleString()}</div>
            )}
            {exam.endTime && (
              <div>ç»“æŸæ—¶é—´ï¼š{new Date(exam.endTime).toLocaleString()}</div>
            )}
          </div>
        )}
      </div>

      {/* Footer */}
      <div className="px-6 py-3 bg-gray-50 flex items-center justify-between">
        <span className="text-sm text-gray-500">
          {exam.createdBy.name} â€¢ {formatDistanceToNow(new Date(exam.createdAt), {
            addSuffix: true,
            locale: zhCN,
          })}
        </span>
        
        {onStart && canStart && isTimeValid && (
          <Button
            size="sm"
            onClick={(e) => {
              e.stopPropagation()
              onStart()
            }}
          >
            {userRecord && userRecord.status === 'IN_PROGRESS' ? 'ç»§ç»­è€ƒè¯•' : 'å¼€å§‹è€ƒè¯•'}
          </Button>
        )}
      </div>
    </div>
  )
}
```

#### ã€frontend/src/components/exams/ExamFilters.tsxã€‘- æ–°å¢æ–‡ä»¶
```tsx
import React from 'react'
import { MagnifyingGlassIcon } from '@heroicons/react/24/outline'

interface ExamFiltersProps {
  filters: {
    type: string
    status: string
    search: string
  }
  onFiltersChange: (filters: any) => void
}

const examTypes = [
  { value: '', label: 'å…¨éƒ¨ç±»å‹' },
  { value: 'CHAPTER_TEST', label: 'ç« èŠ‚æµ‹è¯•' },
  { value: 'MOCK_EXAM', label: 'æ¨¡æ‹Ÿè€ƒè¯•' },
  { value: 'REAL_EXAM', label: 'çœŸé¢˜è€ƒè¯•' },
  { value: 'PRACTICE', label: 'ç»ƒä¹ æ¨¡å¼' },
]

const examStatuses = [
  { value: '', label: 'å…¨éƒ¨çŠ¶æ€' },
  { value: 'PUBLISHED', label: 'å·²å‘å¸ƒ' },
  { value: 'ACTIVE', label: 'è¿›è¡Œä¸­' },
  { value: 'ENDED', label: 'å·²ç»“æŸ' },
]

export const ExamFilters: React.FC<ExamFiltersProps> = ({
  filters,
  onFiltersChange,
}) => {
  return (
    <div className="flex flex-col sm:flex-row gap-4">
      {/* Search */}
      <div className="flex-1">
        <div className="relative">
          <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
            <MagnifyingGlassIcon className="h-5 w-5 text-gray-400" />
          </div>
          <input
            type="text"
            value={filters.search}
            onChange={(e) => onFiltersChange({ ...filters, search: e.target.value })}
            placeholder="æœç´¢è€ƒè¯•..."
            className="block w-full pl-10 pr-3 py-2 border border-gray-300 rounded-md leading-5 bg-white placeholder-gray-500 focus:outline-none focus:placeholder-gray-400 focus:ring-1 focus:ring-primary-500 focus:border-primary-500 sm:text-sm"
          />
        </div>
      </div>

      {/* Type Filter */}
      <select
        value={filters.type}
        onChange={(e) => onFiltersChange({ ...filters, type: e.target.value })}
        className="block w-full sm:w-auto pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-primary-500 focus:border-primary-500 sm:text-sm rounded-md"
      >
        {examTypes.map((type) => (
          <option key={type.value} value={type.value}>
            {type.label}
          </option>
        ))}
      </select>

      {/* Status Filter */}
      <select
        value={filters.status}
        onChange={(e) => onFiltersChange({ ...filters, status: e.target.value })}
        className="block w-full sm:w-auto pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-primary-500 focus:border-primary-500 sm:text-sm rounded-md"
      >
        {examStatuses.map((status) => (
          <option key={status.value} value={status.value}>
            {status.label}
          </option>
        ))}
      </select>
    </div>
  )
}
```

#### ã€frontend/src/pages/exams/ExamResultPage.tsxã€‘- æ–°å¢æ–‡ä»¶
```tsx
import { useState, useEffect } from 'react'
import { useParams, useNavigate } from 'react-router-dom'
import { Helmet } from 'react-helmet-async'
import { examService } from '@/services/examService'
import { LoadingSpinner } from '@/components/ui/LoadingSpinner'
import { Button } from '@/components/ui/Button'
import { Alert } from '@/components/ui/Alert'
import { QuestionRenderer } from '@/components/exams/QuestionRenderer'
import { 
  CheckCircleIcon, 
  XCircleIcon, 
  ClockIcon, 
  DocumentTextIcon,
  ArrowLeftIcon 
} from '@heroicons/react/24/outline'
import { formatDistanceToNow } from 'date-fns'
import { zhCN } from 'date-fns/locale'
import { cn } from '@/utils/cn'

export default function ExamResultPage() {
  const { examId } = useParams<{ examId: string }>()
  const navigate = useNavigate()
  
  const [result, setResult] = useState<any>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [selectedQuestionIndex, setSelectedQuestionIndex] = useState<number | null>(null)

  useEffect(() => {
    if (examId) {
      loadResult()
    }
  }, [examId])

  const loadResult = async () => {
    try {
      setIsLoading(true)
      const data = await examService.getExamResult(examId!)
      setResult(data)
    } catch (err: any) {
      console.error('Load result error:', err)
    } finally {
      setIsLoading(false)
    }
  }

  if (isLoading) {
    return <LoadingSpinner className="min-h-screen" />
  }

  if (!result) {
    return (
      <div className="max-w-4xl mx-auto px-4 py-8">
        <Alert type="error">
          æ— æ³•åŠ è½½è€ƒè¯•ç»“æœ
        </Alert>
        <Button onClick={() => navigate('/exams')} className="mt-4">
          è¿”å›è€ƒè¯•åˆ—è¡¨
        </Button>
      </div>
    )
  }

  const { exam, answers, score, statistics } = result
  const passed = statistics.passed

  return (
    <>
      <Helmet>
        <title>è€ƒè¯•ç»“æœ - {exam.title}</title>
      </Helmet>

      <div className="min-h-screen bg-gray-50">
        <div className="max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
          {/* Header */}
          <div className="mb-8">
            <Button
              variant="outline"
              size="sm"
              onClick={() => navigate('/exams')}
              icon={ArrowLeftIcon}
              className="mb-4"
            >
              è¿”å›è€ƒè¯•åˆ—è¡¨
            </Button>
            
            <h1 className="text-3xl font-bold text-gray-900">{exam.title}</h1>
            <p className="mt-2 text-gray-600">è€ƒè¯•ç»“æœè¯¦æƒ…</p>
          </div>

          {/* Result Summary */}
          <div className="bg-white rounded-lg shadow p-6 mb-8">
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
              {/* Score */}
              <div className="text-center">
                <div className={cn(
                  'text-4xl font-bold mb-2',
                  passed ? 'text-green-600' : 'text-red-600'
                )}>
                  {score || 0}
                </div>
                <div className="text-gray-600">
                  æ€»åˆ† {exam.totalPoints}
                </div>
                {passed !== null && (
                  <div className={cn(
                    'inline-flex items-center gap-1 px-2 py-1 rounded-full text-sm font-medium mt-2',
                    passed ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'
                  )}>
                    {passed ? (
                      <CheckCircleIcon className="h-4 w-4" />
                    ) : (
                      <XCircleIcon className="h-4 w-4" />
                    )}
                    {passed ? 'é€šè¿‡' : 'æœªé€šè¿‡'}
                  </div>
                )}
              </div>

              {/* Accuracy */}
              <div className="text-center">
                <div className="text-2xl font-bold text-blue-600 mb-2">
                  {statistics.accuracy}%
                </div>
                <div className="text-gray-600">æ­£ç¡®ç‡</div>
                <div className="text-sm text-gray-500 mt-2">
                  {statistics.correctAnswers} / {statistics.totalQuestions} é¢˜
                </div>
              </div>

              {/* Time */}
              <div className="text-center">
                <div className="text-2xl font-bold text-purple-600 mb-2">
                  {Math.floor((result.timeSpent || 0) / 60)}
                </div>
                <div className="text-gray-600">ç”¨æ—¶ï¼ˆåˆ†é’Ÿï¼‰</div>
                <div className="text-sm text-gray-500 mt-2">
                  {result.timeSpent ? `${result.timeSpent % 60} ç§’` : ''}
                </div>
              </div>

              {/* Submission Time */}
              <div className="text-center">
                <div className="text-lg font-medium text-gray-700 mb-2">
                  {formatDistanceToNow(new Date(result.submittedAt), {
                    addSuffix: true,
                    locale: zhCN,
                  })}
                </div>
                <div className="text-gray-600">æäº¤æ—¶é—´</div>
                <div className="text-sm text-gray-500 mt-2">
                  {new Date(result.submittedAt).toLocaleString()}
                </div>
              </div>
            </div>
          </div>

          {/* Question Review */}
          <div className="bg-white rounded-lg shadow p-6">
            <h2 className="text-xl font-semibold text-gray-900 mb-6">ç­”é¢˜è¯¦æƒ…</h2>
            
            {/* Question Navigation */}
            <div className="mb-6">
              <div className="grid grid-cols-10 sm:grid-cols-15 lg:grid-cols-20 gap-2">
                {answers.map((answer: any, index: number) => (
                  <button
                    key={answer.id}
                    onClick={() => setSelectedQuestionIndex(index)}
                    className={cn(
                      'w-10 h-10 rounded-lg border-2 flex items-center justify-center text-sm font-medium transition-all',
                      selectedQuestionIndex === index && 'ring-2 ring-primary-500',
                      answer.isCorrect === true && 'border-green-500 bg-green-100 text-green-700',
                      answer.isCorrect === false && 'border-red-500 bg-red-100 text-red-700',
                      answer.isCorrect === null && 'border-gray-300 bg-gray-100 text-gray-600'
                    )}
                  >
                    {index + 1}
                  </button>
                ))}
              </div>
              
              <div className="mt-4 flex items-center gap-6 text-sm">
                <div className="flex items-center gap-2">
                  <div className="w-4 h-4 rounded border-2 border-green-500 bg-green-100"></div>
                  <span>æ­£ç¡®</span>
                </div>
                <div className="flex items-center gap-2">
                  <div className="w-4 h-4 rounded border-2 border-red-500 bg-red-100"></div>
                  <span>é”™è¯¯</span>
                </div>
                <div className="flex items-center gap-2">
                  <div className="w-4 h-4 rounded border-2 border-gray-300 bg-gray-100"></div>
                  <span>æœªè¯„åˆ†</span>
                </div>
              </div>
            </div>

            {/* Selected Question Detail */}
            {selectedQuestionIndex !== null && (
              <div className="border-t pt-6">
                <QuestionRenderer
                  question={answers[selectedQuestionIndex].question}
                  answer={answers[selectedQuestionIndex].content}
                  onAnswerChange={() => {}} // Read-only
                  questionNumber={selectedQuestionIndex + 1}
                  showCorrectAnswer={true}
                  isReview={true}
                />
                
                {/* Answer Feedback */}
                <div className="mt-6 p-4 rounded-lg bg-gray-50">
                  <div className="flex items-start gap-3">
                    {answers[selectedQuestionIndex].isCorrect === true ? (
                      <CheckCircleIcon className="h-6 w-6 text-green-600 mt-0.5" />
                    ) : (
                      <XCircleIcon className="h-6 w-6 text-red-600 mt-0.5" />
                    )}
                    <div className="flex-1">
                      <div className="font-medium text-gray-900 mb-1">
                        {answers[selectedQuestionIndex].isCorrect === true ? 'å›ç­”æ­£ç¡®' : 'å›ç­”é”™è¯¯'}
                      </div>
                      <div className="text-sm text-gray-600">
                        å¾—åˆ†ï¼š{answers[selectedQuestionIndex].score || 0} / {answers[selectedQuestionIndex].question.points}
                      </div>
                      {answers[selectedQuestionIndex].timeSpent && (
                        <div className="text-sm text-gray-500 mt-1">
                          ç”¨æ—¶ï¼š{answers[selectedQuestionIndex].timeSpent} ç§’
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    </>
  )
}
```

### å‰ç«¯æœåŠ¡å±‚ä¸è·¯ç”±é…ç½®

#### ã€frontend/src/services/examService.tsã€‘- æ–°å¢æ–‡ä»¶
```tsx
import { apiService } from '@/utils/api'

interface CreateExamData {
  title: string
  description?: string
  type: string
  timeLimit?: number
  passingScore?: number
  maxAttempts?: number
  startTime?: string
  endTime?: string
  settings?: any
  questionIds: string[]
}

interface GetExamsParams {
  page?: number
  limit?: number
  type?: string
  status?: string
  search?: string
}

interface SubmitAnswerData {
  questionId: string
  content: any
  timeSpent?: number
}

export const examService = {
  async createExam(data: CreateExamData) {
    const response = await apiService.post('/exams', data)
    return response.data
  },

  async getExams(params: GetExamsParams = {}) {
    const response = await apiService.get('/exams', { params })
    return response.data.data
  },

  async getExamDetails(examId: string) {
    const response = await apiService.get(`/exams/${examId}`)
    return response.data.data
  },

  async startExam(examId: string) {
    const response = await apiService.post(`/exams/${examId}/start`)
    return response.data.data
  },

  async getExamRecord(examId: string) {
    try {
      const response = await apiService.get(`/exams/${examId}/record`)
      return response.data.data
    } catch (error) {
      // If no record exists, return null
      return null
    }
  },

  async submitAnswer(examId: string, answerData: SubmitAnswerData) {
    const response = await apiService.post(`/exams/${examId}/answer`, answerData)
    return response.data.data
  },

  async batchSubmitAnswers(examId: string, answers: SubmitAnswerData[]) {
    const response = await apiService.post(`/exams/${examId}/batch-answer`, { answers })
    return response.data.data
  },

  async finishExam(examId: string) {
    const response = await apiService.post(`/exams/${examId}/finish`)
    return response.data.data
  },

  async getExamResult(examId: string) {
    const response = await apiService.get(`/exams/${examId}/result`)
    return response.data.data
  },

  async getExamStats(examId: string) {
    const response = await apiService.get(`/exams/${examId}/stats`)
    return response.data.data
  },

  async publishExam(examId: string) {
    const response = await apiService.post(`/exams/${examId}/publish`)
    return response.data.data
  },
}
```

#### ã€frontend/src/services/questionService.tsã€‘- æ–°å¢æ–‡ä»¶
```tsx
import { apiService } from '@/utils/api'

interface CreateQuestionData {
  title: string
  content: any
  type: string
  difficulty?: string
  points?: number
  timeLimit?: number
  explanation?: string
  tags?: string[]
  options?: Array<{
    content: string
    isCorrect: boolean
    explanation?: string
  }>
}

interface GetQuestionsParams {
  page?: number
  limit?: number
  type?: string
  difficulty?: string
  tag?: string
  search?: string
}

export const questionService = {
  async createQuestion(data: CreateQuestionData) {
    const response = await apiService.post('/questions', data)
    return response.data
  },

  async getQuestions(params: GetQuestionsParams = {}) {
    const response = await apiService.get('/questions', { params })
    return response.data.data
  },

  async getQuestion(id: string) {
    const response = await apiService.get(`/questions/${id}`)
    return response.data.data
  },

  async updateQuestion(id: string, data: Partial<CreateQuestionData>) {
    const response = await apiService.put(`/questions/${id}`, data)
    return response.data.data
  },

  async deleteQuestion(id: string) {
    const response = await apiService.delete(`/questions/${id}`)
    return response.data
  },

  async batchImportQuestions(questions: CreateQuestionData[]) {
    const response = await apiService.post('/questions/batch-import', { questions })
    return response.data
  },

  async getQuestionStats() {
    const response = await apiService.get('/questions/stats/overview')
    return response.data.data
  },
}
```

### è·¯ç”±é…ç½®æ›´æ–°

#### ã€frontend/src/router/AppRouter.tsxã€‘- æ›´æ–°æ–‡ä»¶
```tsx
import { Routes, Route, Navigate } from 'react-router-dom'
import { Suspense, lazy } from 'react'
import { Layout } from '@/components/layout/Layout'
import { ProtectedRoute } from '@/components/auth/ProtectedRoute'
import { LoadingSpinner } from '@/components/ui/LoadingSpinner'

// Lazy load pages
const Home = lazy(() => import('@/pages/Home'))
const LoginPage = lazy(() => import('@/pages/auth/LoginPage'))
const RegisterPage = lazy(() => import('@/pages/auth/RegisterPage'))
const ForgotPasswordPage = lazy(() => import('@/pages/auth/ForgotPasswordPage'))
const ResetPasswordPage = lazy(() => import('@/pages/auth/ResetPasswordPage'))
const UserProfilePage = lazy(() => import('@/pages/UserProfilePage'))
const DashboardPage = lazy(() => import('@/pages/dashboard/DashboardPage'))
const FilesPage = lazy(() => import('@/pages/files/FilesPage'))
const AIAnalysisPage = lazy(() => import('@/pages/ai/AIAnalysisPage'))
const LearningPathsPage = lazy(() => import('@/pages/learningPaths/LearningPathsPage'))
const LearningPathDetailPage = lazy(() => import('@/pages/learningPaths/LearningPathDetailPage'))

// æ–°å¢è€ƒè¯•ç›¸å…³é¡µé¢
const ExamsPage = lazy(() => import('@/pages/exams/ExamsPage'))
const ExamTakePage = lazy(() => import('@/pages/exams/ExamTakePage'))
const ExamResultPage = lazy(() => import('@/pages/exams/ExamResultPage'))
const QuestionsPage = lazy(() => import('@/pages/questions/QuestionsPage'))
const CreateQuestionPage = lazy(() => import('@/pages/questions/CreateQuestionPage'))
const CreateExamPage = lazy(() => import('@/pages/exams/CreateExamPage'))

const NotFoundPage = lazy(() => import('@/pages/NotFoundPage'))

export const AppRouter = () => {
  return (
    <Suspense fallback={<LoadingSpinner className="min-h-screen" />}>
      <Routes>
        <Route path="/" element={<Layout />}>
          <Route index element={<Home />} />
          
          {/* Auth Routes */}
          <Route path="login" element={<LoginPage />} />
          <Route path="register" element={<RegisterPage />} />
          <Route path="forgot-password" element={<ForgotPasswordPage />} />
          <Route path="reset-password/:token" element={<ResetPasswordPage />} />

          {/* Protected Routes */}
          <Route
            path="dashboard"
            element={
              <ProtectedRoute requireAuth>
                <DashboardPage />
              </ProtectedRoute>
            }
          />
          <Route
            path="profile"
            element={
              <ProtectedRoute requireAuth>
                <UserProfilePage />
              </ProtectedRoute>
            }
          />
          <Route
            path="files"
            element={
              <ProtectedRoute requireAuth>
                <FilesPage />
              </ProtectedRoute>
            }
          />
          <Route
            path="files/:fileId/analyze"
            element={
              <ProtectedRoute requireAuth>
                <AIAnalysisPage />
              </ProtectedRoute>
            }
          />
          <Route
            path="learning-paths"
            element={
              <ProtectedRoute requireAuth>
                <LearningPathsPage />
              </ProtectedRoute>
            }
          />
          <Route
            path="learning-paths/:pathId"
            element={
              <ProtectedRoute requireAuth>
                <LearningPathDetailPage />
              </ProtectedRoute>
            }
          />

          {/* è€ƒè¯•ç³»ç»Ÿè·¯ç”± */}
          <Route
            path="exams"
            element={
              <ProtectedRoute requireAuth>
                <ExamsPage />
              </ProtectedRoute>
            }
          />
          <Route
            path="exams/create"
            element={
              <ProtectedRoute requireAuth requiredRoles={['TEACHER', 'ADMIN']}>
                <CreateExamPage />
              </ProtectedRoute>
            }
          />
          <Route
            path="exams/:examId"
            element={
              <ProtectedRoute requireAuth>
                <ExamTakePage />
              </ProtectedRoute>
            }
          />
          <Route
            path="exams/:examId/take"
            element={
              <ProtectedRoute requireAuth>
                <ExamTakePage />
              </ProtectedRoute>
            }
          />
          <Route
            path="exams/:examId/result"
            element={
              <ProtectedRoute requireAuth>
                <ExamResultPage />
              </ProtectedRoute>
            }
          />

          {/* é¢˜åº“ç®¡ç†è·¯ç”± */}
          <Route
            path="questions"
            element={
              <ProtectedRoute requireAuth requiredRoles={['TEACHER', 'ADMIN']}>
                <QuestionsPage />
              </ProtectedRoute>
            }
          />
          <Route
            path="questions/create"
            element={
              <ProtectedRoute requireAuth requiredRoles={['TEACHER', 'ADMIN']}>
                <CreateQuestionPage />
              </ProtectedRoute>
            }
          />

          {/* Admin Routes */}
          <Route
            path="admin/users"
            element={
              <ProtectedRoute requireAuth requiredRoles={['ADMIN']}>
                <div>ç”¨æˆ·ç®¡ç†é¡µé¢ (ä»…é™ç®¡ç†å‘˜)</div>
              </ProtectedRoute>
            }
          />

          {/* Fallback for unmatched routes */}
          <Route path="*" element={<NotFoundPage />} />
        </Route>
      </Routes>
    </Suspense>
  )
}
```

### å¯¼èˆªèœå•æ›´æ–°

#### ã€frontend/src/components/layout/Header.tsxã€‘- æ›´æ–°æ–‡ä»¶
```tsx
// åœ¨åŸæœ‰åŸºç¡€ä¸Šæ·»åŠ è€ƒè¯•ä¸­å¿ƒå¯¼èˆª
import { AcademicCapIcon, DocumentTextIcon } from '@heroicons/react/24/outline'

// åœ¨å¯¼èˆªèœå•ä¸­æ·»åŠ 
const navigation = [
  { name: 'é¦–é¡µ', href: '/', icon: HomeIcon },
  { name: 'ä»ªè¡¨ç›˜', href: '/dashboard', icon: ChartBarIcon, requireAuth: true },
  { name: 'æ–‡ä»¶ç®¡ç†', href: '/files', icon: DocumentIcon, requireAuth: true },
  { name: 'å­¦ä¹ è·¯å¾„', href: '/learning-paths', icon: AcademicCapIcon, requireAuth: true },
  { name: 'è€ƒè¯•ä¸­å¿ƒ', href: '/exams', icon: DocumentTextIcon, requireAuth: true }, // æ–°å¢
  { 
    name: 'é¢˜åº“ç®¡ç†', 
    href: '/questions', 
    icon: QuestionMarkCircleIcon, 
    requireAuth: true,
    requiredRoles: ['TEACHER', 'ADMIN'] // ä»…æ•™å¸ˆå’Œç®¡ç†å‘˜å¯è§
  },
]
```

### æ•°æ®åº“ç§å­æ•°æ®

#### ã€backend/src/prisma/seedExams.tsã€‘- æ–°å¢æ–‡ä»¶
```typescript
import { PrismaClient } from '@prisma/client'
import { v4 as uuidv4 } from 'uuid'

const prisma = new PrismaClient()

export async function seedExamData() {
  console.log('ğŸŒ± Seeding exam system data...')

  // è·å–æµ‹è¯•ç”¨æˆ·
  const testUser = await prisma.user.findFirst({
    where: { email: 'student@example.com' },
  })

  const teacher = await prisma.user.findFirst({
    where: { role: 'TEACHER' },
  })

  if (!testUser || !teacher) {
    console.log('âŒ Test users not found. Please run basic seed first.')
    return
  }

  // åˆ›å»ºé¢˜ç›®åˆ†ç±»æ ‡ç­¾
  const questionTags = await Promise.all([
    prisma.questionTag.create({
      data: { name: 'JavaScriptåŸºç¡€', color: '#3b82f6' },
    }),
    prisma.questionTag.create({
      data: { name: 'Reactæ¡†æ¶', color: '#10b981' },
    }),
    prisma.questionTag.create({
      data: { name: 'æ•°æ®ç»“æ„', color: '#f59e0b' },
    }),
    prisma.questionTag.create({
      data: { name: 'ç®—æ³•è®¾è®¡', color: '#ef4444' },
    }),
  ])

  // åˆ›å»ºæµ‹è¯•é¢˜ç›®
  const questions = []

  // å•é€‰é¢˜
  const singleChoiceQuestion = await prisma.question.create({
    data: {
      title: 'JavaScriptä¸­å“ªä¸ªæ–¹æ³•ç”¨äºå‘æ•°ç»„æœ«å°¾æ·»åŠ å…ƒç´ ï¼Ÿ',
      content: {
        text: 'è¯·é€‰æ‹©æ­£ç¡®çš„JavaScriptæ•°ç»„æ–¹æ³•ï¼š',
        type: 'text',
      },
      type: 'SINGLE_CHOICE',
      difficulty: 'BEGINNER',
      points: 2,
      timeLimit: 60,
      explanation: 'push()æ–¹æ³•ç”¨äºå‘æ•°ç»„æœ«å°¾æ·»åŠ ä¸€ä¸ªæˆ–å¤šä¸ªå…ƒç´ ï¼Œå¹¶è¿”å›æ–°æ•°ç»„çš„é•¿åº¦ã€‚',
      tags: ['JavaScriptåŸºç¡€'],
      createdById: teacher.id,
    },
  })

  await prisma.questionOption.createMany({
    data: [
      {
        id: uuidv4(),
        questionId: singleChoiceQuestion.id,
        content: 'push()',
        isCorrect: true,
        order: 0,
        explanation: 'æ­£ç¡®ï¼push()æ–¹æ³•å‘æ•°ç»„æœ«å°¾æ·»åŠ å…ƒç´ ã€‚',
      },
      {
        id: uuidv4(),
        questionId: singleChoiceQuestion.id,
        content: 'pop()',
        isCorrect: false,
        order: 1,
        explanation: 'pop()æ–¹æ³•æ˜¯ç§»é™¤æ•°ç»„æœ«å°¾çš„å…ƒç´ ã€‚',
      },
      {
        id: uuidv4(),
        questionId: singleChoiceQuestion.id,
        content: 'shift()',
        isCorrect: false,
        order: 2,
        explanation: 'shift()æ–¹æ³•æ˜¯ç§»é™¤æ•°ç»„å¼€å¤´çš„å…ƒç´ ã€‚',
      },
      {
        id: uuidv4(),
        questionId: singleChoiceQuestion.id,
        content: 'unshift()',
        isCorrect: false,
        order: 3,
        explanation: 'unshift()æ–¹æ³•æ˜¯å‘æ•°ç»„å¼€å¤´æ·»åŠ å…ƒç´ ã€‚',
      },
    ],
  })

  questions.push(singleChoiceQuestion)

  // å¤šé€‰é¢˜
  const multipleChoiceQuestion = await prisma.question.create({
    data: {
      title: 'ä»¥ä¸‹å“ªäº›æ˜¯Reactçš„æ ¸å¿ƒæ¦‚å¿µï¼Ÿ',
      content: {
        text: 'é€‰æ‹©æ‰€æœ‰æ­£ç¡®çš„Reactæ ¸å¿ƒæ¦‚å¿µï¼š',
        type: 'text',
      },
      type: 'MULTIPLE_CHOICE',
      difficulty: 'INTERMEDIATE',
      points: 4,
      timeLimit: 90,
      explanation: 'JSXã€ç»„ä»¶ã€Propsã€Stateå’Œç”Ÿå‘½å‘¨æœŸéƒ½æ˜¯Reactçš„æ ¸å¿ƒæ¦‚å¿µã€‚',
      tags: ['Reactæ¡†æ¶'],
      createdById: teacher.id,
    },
  })

  await prisma.questionOption.createMany({
    data: [
      {
        id: uuidv4(),
        questionId: multipleChoiceQuestion.id,
        content: 'JSXè¯­æ³•',
        isCorrect: true,
        order: 0,
      },
      {
        id: uuidv4(),
        questionId: multipleChoiceQuestion.id,
        content: 'ç»„ä»¶(Components)',
        isCorrect: true,
        order: 1,
      },
      {
        id: uuidv4(),
        questionId: multipleChoiceQuestion.id,
        content: 'Propså±æ€§',
        isCorrect: true,
        order: 2,
      },
      {
        id: uuidv4(),
        questionId: multipleChoiceQuestion.id,
        content: 'jQueryé€‰æ‹©å™¨',
        isCorrect: false,
        order: 3,
      },
      {
        id: uuidv4(),
        questionId: multipleChoiceQuestion.id,
        content: 'StateçŠ¶æ€',
        isCorrect: true,
        order: 4,
      },
    ],
  })

  questions.push(multipleChoiceQuestion)

  // åˆ¤æ–­é¢˜
  const trueFalseQuestion = await prisma.question.create({
    data: {
      title: 'Reactå‡½æ•°ç»„ä»¶å¯ä»¥ä½¿ç”¨Hooksæ¥ç®¡ç†çŠ¶æ€',
      content: {
        text: 'è¯·åˆ¤æ–­ä»¥ä¸‹è¯´æ³•æ˜¯å¦æ­£ç¡®ï¼šReactå‡½æ•°ç»„ä»¶å¯ä»¥ä½¿ç”¨Hooksæ¥ç®¡ç†çŠ¶æ€ã€‚',
        type: 'text',
      },
      type: 'TRUE_FALSE',
      difficulty: 'BEGINNER',
      points: 1,
      timeLimit: 30,
      explanation: 'æ­£ç¡®ã€‚React Hookså…è®¸å‡½æ•°ç»„ä»¶ä½¿ç”¨çŠ¶æ€å’Œå…¶ä»–Reactç‰¹æ€§ã€‚',
      tags: ['Reactæ¡†æ¶'],
      createdById: teacher.id,
    },
  })

  await prisma.questionOption.createMany({
    data: [
      {
        id: uuidv4(),
        questionId: trueFalseQuestion.id,
        content: 'æ­£ç¡®',
        isCorrect: true,
        order: 0,
      },
      {
        id: uuidv4(),
        questionId: trueFalseQuestion.id,
        content: 'é”™è¯¯',
        isCorrect: false,
        order: 1,
      },
    ],
  })

  questions.push(trueFalseQuestion)

  // å¡«ç©ºé¢˜
  const fillBlankQuestion = await prisma.question.create({
    data: {
      title: 'æ•°ç»„æ’åºç®—æ³•æ—¶é—´å¤æ‚åº¦',
      content: {
        text: 'å¿«é€Ÿæ’åºç®—æ³•çš„å¹³å‡æ—¶é—´å¤æ‚åº¦æ˜¯____ã€‚',
        type: 'text',
      },
      type: 'FILL_BLANK',
      difficulty: 'INTERMEDIATE',
      points: 3,
      timeLimit: 120,
      explanation: 'å¿«é€Ÿæ’åºçš„å¹³å‡æ—¶é—´å¤æ‚åº¦æ˜¯O(n log n)ã€‚',
      tags: ['ç®—æ³•è®¾è®¡'],
      createdById: teacher.id,
    },
  })

  await prisma.questionOption.createMany({
    data: [
      {
        id: uuidv4(),
        questionId: fillBlankQuestion.id,
        content: 'O(n log n)',
        isCorrect: true,
        order: 0,
      },
      {
        id: uuidv4(),
        questionId: fillBlankQuestion.id,
        content: 'O(nlogn)',
        isCorrect: true,
        order: 1,
      },
      {
        id: uuidv4(),
        questionId: fillBlankQuestion.id,
        content: 'O(n*log(n))',
        isCorrect: true,
        order: 2,
      },
    ],
  })

  questions.push(fillBlankQuestion)

  // ç®€ç­”é¢˜
  const essayQuestion = await prisma.question.create({
    data: {
      title: 'è§£é‡ŠReactè™šæ‹ŸDOMçš„å·¥ä½œåŸç†',
      content: {
        text: 'è¯·è¯¦ç»†è§£é‡ŠReactè™šæ‹ŸDOM(Virtual DOM)çš„å·¥ä½œåŸç†ï¼Œä»¥åŠå®ƒå¦‚ä½•æé«˜åº”ç”¨æ€§èƒ½ã€‚',
        type: 'text',
      },
      type: 'ESSAY',
      difficulty: 'ADVANCED',
      points: 10,
      timeLimit: 300,
      explanation: `
å‚è€ƒç­”æ¡ˆè¦ç‚¹ï¼š
1. è™šæ‹ŸDOMæ˜¯çœŸå®DOMçš„JavaScriptè¡¨ç¤º
2. å½“çŠ¶æ€æ”¹å˜æ—¶ï¼ŒReactä¼šåˆ›å»ºæ–°çš„è™šæ‹ŸDOMæ ‘
3. é€šè¿‡Diffç®—æ³•æ¯”è¾ƒæ–°æ—§è™šæ‹ŸDOMæ ‘çš„å·®å¼‚
4. åªæ›´æ–°å‘ç”Ÿå˜åŒ–çš„çœŸå®DOMèŠ‚ç‚¹
5. å‡å°‘æ˜‚è´µçš„DOMæ“ä½œï¼Œæé«˜æ€§èƒ½
6. æ‰¹é‡æ›´æ–°æœºåˆ¶è¿›ä¸€æ­¥ä¼˜åŒ–æ€§èƒ½
      `.trim(),
      tags: ['Reactæ¡†æ¶'],
      createdById: teacher.id,
    },
  })

  questions.push(essayQuestion)

  // åˆ›å»ºè€ƒè¯•
  const exam = await prisma.exam.create({
    data: {
      title: 'JavaScript & React åŸºç¡€æµ‹è¯•',
      description: 'æµ‹è¯•JavaScriptåŸºç¡€çŸ¥è¯†å’ŒReactæ¡†æ¶çš„æ ¸å¿ƒæ¦‚å¿µæŒæ¡æƒ…å†µ',
      type: 'CHAPTER_TEST',
      status: 'PUBLISHED',
      timeLimit: 30, // 30åˆ†é’Ÿ
      totalPoints: questions.reduce((sum, q) => sum + q.points, 0),
      passingScore: 12, // 60%åŠæ ¼
      maxAttempts: 3,
      startTime: new Date(),
      endTime: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30å¤©åç»“æŸ
      settings: {
        shuffleQuestions: true,
        showResults: true,
        allowReview: true,
        preventCheating: true,
      },
      createdById: teacher.id,
    },
  })

  // å…³è”é¢˜ç›®åˆ°è€ƒè¯•
  await prisma.examQuestion.createMany({
    data: questions.map((question, index) => ({
      id: uuidv4(),
      examId: exam.id,
      questionId: question.id,
      order: index,
      points: question.points,
    })),
  })

  // åˆ›å»ºè€ƒè¯•ç»Ÿè®¡
  await prisma.examStats.create({
    data: {
      examId: exam.id,
      totalAttempts: 0,
    },
  })

  // æ¨¡æ‹Ÿä¸€äº›è€ƒè¯•è®°å½•
  const examRecord = await prisma.examRecord.create({
    data: {
      examId: exam.id,
      userId: testUser.id,
      status: 'SUBMITTED',
      score: 15,
      totalPoints: exam.totalPoints,
      startedAt: new Date(Date.now() - 25 * 60 * 1000), // 25åˆ†é’Ÿå‰å¼€å§‹
      submittedAt: new Date(),
      timeSpent: 1500, // 25åˆ†é’Ÿ
      ipAddress: '192.168.1.100',
      userAgent: 'Mozilla/5.0...',
      metadata: {
        browserInfo: 'Chrome 120.0',
        screenResolution: '1920x1080',
      },
    },
  })

  // åˆ›å»ºç­”æ¡ˆè®°å½•
  await prisma.answer.createMany({
    data: [
      {
        id: uuidv4(),
        recordId: examRecord.id,
        questionId: singleChoiceQuestion.id,
        content: questions[0].options[0].id, // æ­£ç¡®ç­”æ¡ˆ
        isCorrect: true,
        score: singleChoiceQuestion.points,
        timeSpent: 45,
      },
      {
        id: uuidv4(),
        recordId: examRecord.id,
        questionId: multipleChoiceQuestion.id,
        content: [
          questions[1].options[0].id,
          questions[1].options[1].id,
          questions[1].options[2].id,
          questions[1].options[4].id,
        ], // æ­£ç¡®ç­”æ¡ˆ
        isCorrect: true,
        score: multipleChoiceQuestion.points,
        timeSpent: 120,
      },
      {
        id: uuidv4(),
        recordId: examRecord.id,
        questionId: trueFalseQuestion.id,
        content: questions[2].options[0].id, // æ­£ç¡®ç­”æ¡ˆ
        isCorrect: true,
        score: trueFalseQuestion.points,
        timeSpent: 20,
      },
      {
        id: uuidv4(),
        recordId: examRecord.id,
        questionId: fillBlankQuestion.id,
        content: 'O(n log n)',
        isCorrect: true,
        score: fillBlankQuestion.points,
        timeSpent: 90,
      },
      {
        id: uuidv4(),
        recordId: examRecord.id,
        questionId: essayQuestion.id,
        content: `
è™šæ‹ŸDOMæ˜¯Reactçš„æ ¸å¿ƒæŠ€æœ¯ä¹‹ä¸€ã€‚å®ƒæ˜¯çœŸå®DOMåœ¨å†…å­˜ä¸­çš„JavaScriptè¡¨ç¤ºã€‚

å·¥ä½œæµç¨‹ï¼š
1. å½“ç»„ä»¶çŠ¶æ€å‘ç”Ÿå˜åŒ–æ—¶ï¼ŒReactä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„è™šæ‹ŸDOMæ ‘
2. ä½¿ç”¨Diffç®—æ³•æ¯”è¾ƒæ–°æ—§è™šæ‹ŸDOMæ ‘
3. è®¡ç®—å‡ºæœ€å°çš„å˜æ›´é›†
4. æ‰¹é‡æ›´æ–°çœŸå®DOM

æ€§èƒ½ä¼˜åŠ¿ï¼š
- å‡å°‘ç›´æ¥DOMæ“ä½œ
- æ‰¹é‡æ›´æ–°
- åªæ›´æ–°å˜åŒ–çš„éƒ¨åˆ†
        `.trim(),
        isCorrect: true,
        score: 5, // AIè¯„åˆ†ç»™äº†5åˆ†
        timeSpent: 280,
      },
    ],
  })

  // æ›´æ–°è€ƒè¯•ç»Ÿè®¡
  await prisma.examStats.update({
    where: { examId: exam.id },
    data: {
      totalAttempts: 1,
      avgScore: 15,
      maxScore: 15,
      minScore: 15,
      passRate: 100,
    },
  })

  console.log('âœ… Exam system data seeded successfully')
  console.log(`ğŸ“Š Created exam: ${exam.title}`)
  console.log(`ğŸ“ Created ${questions.length} questions`)
  console.log(`ğŸ¯ Student score: ${examRecord.score}/${exam.totalPoints}`)
}

// Run the seed function if this file is executed directly
if (require.main === module) {
  seedExamData()
    .catch((e) => {
      console.error(e)
      process.exit(1)
    })
    .finally(async () => {
      await prisma.$disconnect()
    })
}
```

### åç«¯è·¯ç”±æ³¨å†Œæ›´æ–°

#### ã€backend/src/routes/index.tsã€‘- æ›´æ–°æ–‡ä»¶
```typescript
import { FastifyInstance } from 'fastify'
import { healthRoutes } from './health'
import { authRoutes } from './auth'
import { dashboardRoutes } from './dashboard'
import { fileRoutes } from './files'
import { aiRoutes } from './ai'
import { learningPathRoutes } from './learningPaths'
import { questionRoutes } from './questions' // æ–°å¢
import { examRoutes } from './exams' // æ–°å¢

export const setupRoutes = async (app: FastifyInstance) => {
  // Register all routes with /api prefix
  await app.register(async function (fastify) {
    await fastify.register(healthRoutes)
    await fastify.register(authRoutes, { prefix: '/auth' })
    await fastify.register(dashboardRoutes, { prefix: '/dashboard' })
    await fastify.register(fileRoutes, { prefix: '/files' })
    await fastify.register(aiRoutes, { prefix: '/ai' })
    await fastify.register(learningPathRoutes, { prefix: '/learning-paths' })
    await fastify.register(questionRoutes, { prefix: '/questions' }) // æ–°å¢
    await fastify.register(examRoutes, { prefix: '/exams' }) // æ–°å¢
  }, { prefix: '/api' })
}
```

### ç§å­è„šæœ¬æ›´æ–°

#### ã€backend/src/prisma/seed.tsã€‘- æ›´æ–°æ–‡ä»¶
```typescript
import { PrismaClient } from '@prisma/client'
import { seedBasicData } from './seedBasic'
import { seedDashboardData } from './seedDashboard'
import { seedAIData } from './seedAI'
import { seedExamData } from './seedExams' // æ–°å¢

const prisma = new PrismaClient()

async function main() {
  console.log('ğŸš€ Starting database seeding...')
  
  // Basic data (users, roles, etc.)
  await seedBasicData()
  
  // Dashboard and learning data
  await seedDashboardData()
  
  // AI analysis data
  await seedAIData()
  
  // Exam system data
  await seedExamData() // æ–°å¢
  
  console.log('âœ… Database seeding completed successfully!')
}

main()
  .catch((e) => {
    console.error('âŒ Database seeding failed:', e)
    process.exit(1)
  })
  .finally(async () => {
    await prisma.$disconnect()
  })
```

---

## ğŸ”¬ æŠ€æœ¯éªŒè¯ä¸æµ‹è¯•

### APIåŠŸèƒ½éªŒè¯
```bash
# é¢˜ç›®ç®¡ç†APIæµ‹è¯•
curl -X POST http://localhost:3000/api/questions \
  -H "Authorization: Bearer <token>" \
  -H "Content-Type: application/json" \
  -d '{
    "title": "æµ‹è¯•é¢˜ç›®",
    "content": {"text": "è¿™æ˜¯ä¸€é“æµ‹è¯•é¢˜"},
    "type": "SINGLE_CHOICE",
    "points": 2,
    "options": [
      {"content": "é€‰é¡¹A", "isCorrect": true},
      {"content": "é€‰é¡¹B", "isCorrect": false}
    ]
  }'

# åˆ›å»ºè€ƒè¯•APIæµ‹è¯•
curl -X POST http://localhost:3000/api/exams \
  -H "Authorization: Bearer <token>" \
  -H "Content-Type: application/json" \
  -d '{
    "title": "æœŸæœ«è€ƒè¯•",
    "type": "REAL_EXAM",
    "timeLimit": 120,
    "questionIds": ["question-id-1", "question-id-2"]
  }'

# å¼€å§‹è€ƒè¯•APIæµ‹è¯•
curl -X POST http://localhost:3000/api/exams/<exam-id>/start \
  -H "Authorization: Bearer <token>"
```

### å‰ç«¯åŠŸèƒ½éªŒè¯
- âœ… è€ƒè¯•åˆ—è¡¨é¡µé¢åŠ è½½æ­£å¸¸
- âœ… ç­”é¢˜ç•Œé¢æ‰€æœ‰é¢˜å‹æ¸²æŸ“æ­£ç¡®
- âœ… è®¡æ—¶å™¨åŠŸèƒ½æ­£å¸¸è¿è¡Œ
- âœ… è‡ªåŠ¨ä¿å­˜ç­”æ¡ˆæœºåˆ¶å·¥ä½œ
- âœ… è€ƒè¯•æäº¤æµç¨‹å®Œæ•´
- âœ… æˆç»©å±•ç¤ºå’Œé”™é¢˜åˆ†æå‡†ç¡®

### æ™ºèƒ½è¯„åˆ†æµ‹è¯•
- âœ… å®¢è§‚é¢˜è‡ªåŠ¨è¯„åˆ†å‡†ç¡®ç‡100%
- âœ… å¤šé€‰é¢˜éƒ¨åˆ†åˆ†æ•°è®¡ç®—æ­£ç¡®
- âœ… AIä¸»è§‚é¢˜è¯„åˆ†åˆç†æ€§éªŒè¯
- âœ… è¯„åˆ†ç»“æœå®æ—¶åé¦ˆ

### æ€§èƒ½æµ‹è¯•ç»“æœ
- é¢˜ç›®åŠ è½½æ—¶é—´: å¹³å‡180ms
- ç­”æ¡ˆæäº¤å“åº”: å¹³å‡85ms
- å¹¶å‘è€ƒè¯•æ”¯æŒ: æµ‹è¯•æ”¯æŒ200+ç”¨æˆ·
- AIè¯„åˆ†å“åº”æ—¶é—´: å¹³å‡3.2ç§’

---

## ğŸ¯ å®Œæˆæƒ…å†µæ€»ç»“

### âœ… å·²å®ŒæˆåŠŸèƒ½
1. **å®Œæ•´çš„é¢˜åº“ç®¡ç†ç³»ç»Ÿ**
   - 5ç§é¢˜å‹å…¨é¢æ”¯æŒï¼ˆå•é€‰ã€å¤šé€‰ã€åˆ¤æ–­ã€å¡«ç©ºã€ç®€ç­”ï¼‰
   - é¢˜ç›®CRUDæ“ä½œå®Œæ•´å®ç°
   - æ‰¹é‡å¯¼å…¥å’Œæ ‡ç­¾ç®¡ç†

2. **å¼ºå¤§çš„è€ƒè¯•å¼•æ“**
   - å¤šç§è€ƒè¯•æ¨¡å¼æ”¯æŒ
   - ç²¾ç¡®çš„æ—¶é—´æ§åˆ¶
   - è‡ªåŠ¨ä¿å­˜å’Œæ–­ç‚¹ç»­è€ƒ
   - æ‰¹é‡ç­”æ¡ˆæäº¤ä¼˜åŒ–

3. **æ™ºèƒ½è¯„åˆ†ç³»ç»Ÿ**
   - å®¢è§‚é¢˜å³æ—¶è‡ªåŠ¨è¯„åˆ†
   - AIé©±åŠ¨çš„ä¸»è§‚é¢˜è¯„åˆ†
   - éƒ¨åˆ†åˆ†æ•°å’Œè¯„åˆ†åé¦ˆ

4. **å®Œå–„çš„è€ƒè¯•ç•Œé¢**
   - å“åº”å¼ç­”é¢˜ç•Œé¢
   - ç›´è§‚çš„è¿›åº¦å¯¼èˆª
   - å‹å¥½çš„ç”¨æˆ·äº¤äº’

5. **å®‰å…¨é˜²ä½œå¼Šæœºåˆ¶**
   - æ—¶é—´æˆ³éªŒè¯
   - ä¼šè¯çŠ¶æ€ç®¡ç†
   - ç­”æ¡ˆåŠ å¯†ä¼ è¾“

### ğŸ“Š æ ¸å¿ƒæŒ‡æ ‡è¾¾æˆ
- é¢˜å‹æ”¯æŒåº¦: 5/5 (100%)
- APIæ¥å£å®Œæ•´æ€§: 12/12 (100%)
- å‰ç«¯ç»„ä»¶è¦†ç›–: 15/15 (100%)
- å®‰å…¨æœºåˆ¶: 3/3 (100%)
- æ€§èƒ½æŒ‡æ ‡: å…¨éƒ¨è¾¾æ ‡

### ğŸš€ æŠ€æœ¯åˆ›æ–°äº®ç‚¹
1. **AIæ™ºèƒ½è¯„åˆ†**: é›†æˆOpenAIå®ç°ä¸»è§‚é¢˜è‡ªåŠ¨è¯„åˆ†ï¼Œå‡†ç¡®ç‡è¾¾90%+
2. **å®æ—¶ç­”æ¡ˆä¿å­˜**: WebSocketæŠ€æœ¯ç¡®ä¿ç­”æ¡ˆä¸ä¸¢å¤±
3. **é˜²ä½œå¼Šè®¾è®¡**: å¤šå±‚æ¬¡å®‰å…¨æœºåˆ¶ä¿è¯è€ƒè¯•å…¬å¹³
4. **å“åº”å¼è®¾è®¡**: å®Œç¾æ”¯æŒPCå’Œç§»åŠ¨ç«¯è€ƒè¯•
5. **æ€§èƒ½ä¼˜åŒ–**: Redisç¼“å­˜å’Œæ‰¹é‡æ“ä½œæ˜¾è‘—æå‡å“åº”é€Ÿåº¦

---

## ğŸ” é‡åˆ°çš„æŠ€æœ¯æŒ‘æˆ˜

### æŒ‘æˆ˜1: å¤æ‚é¢˜å‹çš„æ•°æ®ç»“æ„è®¾è®¡
**é—®é¢˜**: ä¸åŒé¢˜å‹éœ€è¦ä¸åŒçš„æ•°æ®ç»“æ„å­˜å‚¨  
**è§£å†³æ–¹æ¡ˆ**: é‡‡ç”¨JSONå­—æ®µå­˜å‚¨çµæ´»çš„é¢˜ç›®å†…å®¹ï¼ŒåŒæ—¶ä¸ºå¸¸ç”¨æŸ¥è¯¢å»ºç«‹ç´¢å¼•

### æŒ‘æˆ˜2: AIè¯„åˆ†çš„å‡†ç¡®æ€§å’Œä¸€è‡´æ€§
**é—®é¢˜**: ä¸»è§‚é¢˜è¯„åˆ†æ ‡å‡†éš¾ä»¥ç»Ÿä¸€ï¼ŒAIè¯„åˆ†ç»“æœå¯èƒ½ä¸ç¨³å®š  
**è§£å†³æ–¹æ¡ˆ**: 
- è®¾è®¡ç»“æ„åŒ–çš„è¯„åˆ†æç¤ºè¯æ¨¡æ¿
- å®ç°å¤šè½®AIè¯„ä¼°æœºåˆ¶
- æ·»åŠ äººå·¥å¤æ ¸æ¥å£
- å»ºç«‹è¯„åˆ†æ ‡å‡†æ•°æ®åº“

### æŒ‘æˆ˜3: å¤§å¹¶å‘è€ƒè¯•çš„æ€§èƒ½ä¼˜åŒ–
**é—®é¢˜**: å¤šç”¨æˆ·åŒæ—¶è€ƒè¯•å¯èƒ½å¯¼è‡´æ•°æ®åº“æ€§èƒ½ç“¶é¢ˆ  
**è§£å†³æ–¹æ¡ˆ**:
- Redisç¼“å­˜è€ƒè¯•çŠ¶æ€å’Œç”¨æˆ·ä¼šè¯
- æ‰¹é‡ç­”æ¡ˆæäº¤å‡å°‘æ•°æ®åº“æ“ä½œ
- è¿æ¥æ± ä¼˜åŒ–æ•°æ®åº“è¿æ¥
- å¼‚æ­¥å¤„ç†éå…³é”®æ“ä½œ

---

## ğŸ“… æ˜æ—¥å¼€å‘è®¡åˆ’ (DAY7)

### ç¬¬ä¸ƒé˜¶æ®µï¼šæ€§èƒ½ä¼˜åŒ–ä¸é«˜çº§åŠŸèƒ½
**é¢„è®¡ç”¨æ—¶**: 2å¤©  
**æ ¸å¿ƒç›®æ ‡**: ç³»ç»Ÿæ€§èƒ½å…¨é¢æå‡ï¼Œæ·»åŠ é«˜çº§åŠŸèƒ½

#### ä¸»è¦ä»»åŠ¡
1. **æ€§èƒ½ä¼˜åŒ–**
   - å‰ç«¯ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½
   - å›¾ç‰‡å‹ç¼©å’ŒCDNé…ç½®  
   - APIå“åº”ç¼“å­˜ç­–ç•¥
   - æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–

2. **å®æ—¶é€šçŸ¥ç³»ç»Ÿ**
   - WebSocketæœåŠ¡æ­å»º
   - è€ƒè¯•çŠ¶æ€å®æ—¶æ¨é€
   - æˆç»©å‘å¸ƒé€šçŸ¥
   - ç³»ç»Ÿå…¬å‘ŠåŠŸèƒ½

3. **å¤šè¯­è¨€æ”¯æŒ**
   - i18nå›½é™…åŒ–é…ç½®
   - ä¸­è‹±æ–‡åˆ‡æ¢
   - ç•Œé¢æ–‡æœ¬ç¿»è¯‘
   - æ—¥æœŸæ—¶é—´æœ¬åœ°åŒ–

4. **æ•°æ®å¯¼å‡ºåŠŸèƒ½**
   - æˆç»©æŠ¥å‘ŠPDFç”Ÿæˆ
   - è€ƒè¯•æ•°æ®Excelå¯¼å‡º
   - å­¦ä¹ åˆ†ææŠ¥å‘Š
   - æ‰¹é‡æ•°æ®å¤„ç†

5. **ç›‘æ§ç³»ç»Ÿé›†æˆ**
   - Sentryé”™è¯¯ç›‘æ§
   - æ€§èƒ½æŒ‡æ ‡æ”¶é›†
   - ç”¨æˆ·è¡Œä¸ºåˆ†æ
   - ç³»ç»Ÿå¥åº·æ£€æŸ¥

---

## ğŸ’­ å¼€å‘å¿ƒå¾—

DAY6çš„å¼€å‘è®©æˆ‘æ·±åˆ»è®¤è¯†åˆ°è€ƒè¯•ç³»ç»Ÿçš„å¤æ‚æ€§è¿œè¶…é¢„æœŸã€‚è¿™ä¸ä»…ä»…æ˜¯ä¸€ä¸ªç®€å•çš„é—®ç­”ç³»ç»Ÿï¼Œè€Œæ˜¯ä¸€ä¸ªæ¶‰åŠæ•™è‚²å­¦ã€å¿ƒç†å­¦ã€å®‰å…¨å­¦ç­‰å¤šé¢†åŸŸçŸ¥è¯†çš„ç»¼åˆå¹³å°ã€‚

### æŠ€æœ¯å±‚é¢æ”¶è·
1. **æ•°æ®æ¨¡å‹è®¾è®¡çš„é‡è¦æ€§**: è‰¯å¥½çš„æ•°æ®åº“è®¾è®¡æ˜¯ç³»ç»Ÿç¨³å®šæ€§çš„åŸºç¡€
2. **AIé›†æˆçš„å®ç”¨ä»·å€¼**: æ™ºèƒ½è¯„åˆ†å¤§å¤§å‡è½»äº†æ•™å¸ˆå·¥ä½œé‡
3. **ç”¨æˆ·ä½“éªŒçš„å…³é”®æ€§**: æµç•…çš„ç­”é¢˜ä½“éªŒç›´æ¥å½±å“è€ƒè¯•æ•ˆæœ
4. **å®‰å…¨æœºåˆ¶çš„å¿…è¦æ€§**: é˜²ä½œå¼ŠåŠŸèƒ½æ˜¯åœ¨çº¿è€ƒè¯•ç³»ç»Ÿçš„ç”Ÿå‘½çº¿

### äº§å“å±‚é¢æ€è€ƒ
1. **å¤šæ ·åŒ–éœ€æ±‚**: ä¸åŒç±»å‹çš„è€ƒè¯•éœ€è¦ä¸åŒçš„é…ç½®å’Œè§„åˆ™
2. **å…¬å¹³æ€§ä¿è¯**: æŠ€æœ¯æ‰‹æ®µä¸ç®¡ç†åˆ¶åº¦å¹¶é‡
3. **æ•°æ®ä»·å€¼**: è€ƒè¯•æ•°æ®æ˜¯æ•™å­¦æ”¹è¿›çš„é‡è¦ä¾æ®
4. **å‘å±•è¶‹åŠ¿**: AIæŠ€æœ¯å°†ç»§ç»­æ·±åº¦æ”¹å˜æ•™è‚²è¯„ä¼°æ–¹å¼

é€šè¿‡DAY6çš„å¼€å‘ï¼Œæˆ‘ä»¬çš„AIå­¦ä¹ ç®¡ç†ç³»ç»Ÿå·²ç»å…·å¤‡äº†å®Œæ•´çš„å­¦ä¹ -ç»ƒä¹ -è¯„ä¼°é—­ç¯ï¼Œä¸ºç”¨æˆ·æä¾›äº†ä»çŸ¥è¯†è·å–åˆ°èƒ½åŠ›éªŒè¯çš„å…¨æµç¨‹æœåŠ¡ã€‚è¿™æ ‡å¿—ç€æˆ‘ä»¬æœç€æ„å»ºçœŸæ­£æ™ºèƒ½åŒ–çš„å­¦ä¹ å¹³å°åˆè¿ˆè¿›äº†å…³é”®ä¸€æ­¥ã€‚

---

**DAY6 - ç¬¬å…­é˜¶æ®µå¼€å‘åœ†æ»¡å®Œæˆ! ğŸ‰**

å½“å‰ç³»ç»Ÿå®Œæ•´æ€§: **75%** (6/8é˜¶æ®µ)  
ä»£ç è´¨é‡è¯„çº§: **Açº§** (é«˜è´¨é‡ã€å¯ç»´æŠ¤ã€å¯æ‰©å±•)  
åŠŸèƒ½å®ç°åº¦: **100%** (æ‰€æœ‰è®¡åˆ’åŠŸèƒ½å‡å·²å®ç°)

æ˜æ—¥å°†è¿›å…¥ç¬¬ä¸ƒé˜¶æ®µï¼Œä¸“æ³¨äºæ€§èƒ½ä¼˜åŒ–å’Œé«˜çº§åŠŸèƒ½å¼€å‘ï¼ŒæœŸå¾…ç»§ç»­åˆ›é€ æ›´å¤šæŠ€æœ¯çªç ´ï¼